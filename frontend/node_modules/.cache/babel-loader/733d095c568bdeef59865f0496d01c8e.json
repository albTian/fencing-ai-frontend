{"ast":null,"code":"import * as poseDetection from '@tensorflow-models/pose-detection';\n/**\n * Draw the keypoints and skeleton on the video.\n * @param poses A list of poses to render.\n * @param ctx The context object to draw on\n * @param scoreThreshold The minimum score needed\n */\n\nfunction drawResults(poses, ctx, scoreThreshold) {\n  console.log(\"drawing\");\n  console.log(poses);\n\n  for (const pose of poses) {\n    drawResult(pose, ctx, scoreThreshold);\n  }\n}\n/**\n  * Draw the keypoints and skeleton on the video.\n  * @param pose A pose with keypoints to render.\n  */\n\n\nfunction drawResult(pose, ctx, scoreThreshold) {\n  if (pose.keypoints != null) {\n    drawKeypoints(pose.keypoints, ctx, scoreThreshold); // drawSkeleton(pose.keypoints, pose.id);\n  }\n}\n/**\n * Draw the keypoints on the video.\n * @param keypoints A list of keypoints.\n */\n\n\nfunction drawKeypoints(keypoints, ctx, scoreThreshold) {\n  // Hardcoding MoveNet in\n  const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet);\n  ctx.fillStyle = 'Red';\n  ctx.strokeStyle = 'White';\n  ctx.lineWidth = 2;\n\n  for (const i of keypointInd.middle) {\n    drawKeypoint(keypoints[i], ctx, scoreThreshold);\n  }\n\n  ctx.fillStyle = 'Green';\n\n  for (const i of keypointInd.left) {\n    drawKeypoint(keypoints[i], ctx, scoreThreshold);\n  }\n\n  ctx.fillStyle = 'Orange';\n\n  for (const i of keypointInd.right) {\n    drawKeypoint(keypoints[i], ctx, scoreThreshold);\n  }\n}\n\nfunction drawKeypoint(keypoint, ctx, scoreThreshold) {\n  // If score is null, just show the keypoint.\n  const score = keypoint.score != null ? keypoint.score : 1;\n  const minScore = scoreThreshold || 0;\n\n  if (score >= minScore) {\n    const circle = new Path2D();\n    circle.arc(keypoint.x, keypoint.y, 4, 0, 2 * Math.PI);\n    ctx.fill(circle);\n    ctx.stroke(circle);\n  }\n}\n\nexport { drawResults };","map":{"version":3,"sources":["/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/src/utils/drawUtils.js"],"names":["poseDetection","drawResults","poses","ctx","scoreThreshold","console","log","pose","drawResult","keypoints","drawKeypoints","keypointInd","util","getKeypointIndexBySide","SupportedModels","MoveNet","fillStyle","strokeStyle","lineWidth","i","middle","drawKeypoint","left","right","keypoint","score","minScore","circle","Path2D","arc","x","y","Math","PI","fill","stroke"],"mappings":"AAAA,OAAO,KAAKA,aAAZ,MAA+B,mCAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,GAA5B,EAAiCC,cAAjC,EAAiD;AAC7CC,EAAAA,OAAO,CAACC,GAAR,CAAY,SAAZ;AACAD,EAAAA,OAAO,CAACC,GAAR,CAAYJ,KAAZ;;AACA,OAAK,MAAMK,IAAX,IAAmBL,KAAnB,EAA0B;AACtBM,IAAAA,UAAU,CAACD,IAAD,EAAOJ,GAAP,EAAYC,cAAZ,CAAV;AACH;AACJ;AAED;AACA;AACA;AACA;;;AACA,SAASI,UAAT,CAAoBD,IAApB,EAA0BJ,GAA1B,EAA+BC,cAA/B,EAA+C;AAC3C,MAAIG,IAAI,CAACE,SAAL,IAAkB,IAAtB,EAA4B;AACxBC,IAAAA,aAAa,CAACH,IAAI,CAACE,SAAN,EAAiBN,GAAjB,EAAsBC,cAAtB,CAAb,CADwB,CAExB;AACH;AACJ;AAED;AACA;AACA;AACA;;;AACA,SAASM,aAAT,CAAuBD,SAAvB,EAAkCN,GAAlC,EAAuCC,cAAvC,EAAuD;AACnD;AACA,QAAMO,WAAW,GAAGX,aAAa,CAACY,IAAd,CAAmBC,sBAAnB,CAA0Cb,aAAa,CAACc,eAAd,CAA8BC,OAAxE,CAApB;AACAZ,EAAAA,GAAG,CAACa,SAAJ,GAAgB,KAAhB;AACAb,EAAAA,GAAG,CAACc,WAAJ,GAAkB,OAAlB;AACAd,EAAAA,GAAG,CAACe,SAAJ,GAAgB,CAAhB;;AAEA,OAAK,MAAMC,CAAX,IAAgBR,WAAW,CAACS,MAA5B,EAAoC;AAChCC,IAAAA,YAAY,CAACZ,SAAS,CAACU,CAAD,CAAV,EAAehB,GAAf,EAAoBC,cAApB,CAAZ;AACH;;AAEDD,EAAAA,GAAG,CAACa,SAAJ,GAAgB,OAAhB;;AACA,OAAK,MAAMG,CAAX,IAAgBR,WAAW,CAACW,IAA5B,EAAkC;AAC9BD,IAAAA,YAAY,CAACZ,SAAS,CAACU,CAAD,CAAV,EAAehB,GAAf,EAAoBC,cAApB,CAAZ;AACH;;AAEDD,EAAAA,GAAG,CAACa,SAAJ,GAAgB,QAAhB;;AACA,OAAK,MAAMG,CAAX,IAAgBR,WAAW,CAACY,KAA5B,EAAmC;AAC/BF,IAAAA,YAAY,CAACZ,SAAS,CAACU,CAAD,CAAV,EAAehB,GAAf,EAAoBC,cAApB,CAAZ;AACH;AACJ;;AAED,SAASiB,YAAT,CAAsBG,QAAtB,EAAgCrB,GAAhC,EAAqCC,cAArC,EAAqD;AACjD;AACA,QAAMqB,KAAK,GAAGD,QAAQ,CAACC,KAAT,IAAkB,IAAlB,GAAyBD,QAAQ,CAACC,KAAlC,GAA0C,CAAxD;AACA,QAAMC,QAAQ,GAAGtB,cAAc,IAAI,CAAnC;;AAEA,MAAIqB,KAAK,IAAIC,QAAb,EAAuB;AACnB,UAAMC,MAAM,GAAG,IAAIC,MAAJ,EAAf;AACAD,IAAAA,MAAM,CAACE,GAAP,CAAWL,QAAQ,CAACM,CAApB,EAAuBN,QAAQ,CAACO,CAAhC,EAAmC,CAAnC,EAAsC,CAAtC,EAAyC,IAAIC,IAAI,CAACC,EAAlD;AACA9B,IAAAA,GAAG,CAAC+B,IAAJ,CAASP,MAAT;AACAxB,IAAAA,GAAG,CAACgC,MAAJ,CAAWR,MAAX;AACH;AACJ;;AAED,SAAS1B,WAAT","sourcesContent":["import * as poseDetection from '@tensorflow-models/pose-detection'\n\n/**\n * Draw the keypoints and skeleton on the video.\n * @param poses A list of poses to render.\n * @param ctx The context object to draw on\n * @param scoreThreshold The minimum score needed\n */\nfunction drawResults(poses, ctx, scoreThreshold) {\n    console.log(\"drawing\")\n    console.log(poses)\n    for (const pose of poses) {\n        drawResult(pose, ctx, scoreThreshold);\n    }\n}\n\n/**\n  * Draw the keypoints and skeleton on the video.\n  * @param pose A pose with keypoints to render.\n  */\nfunction drawResult(pose, ctx, scoreThreshold) {\n    if (pose.keypoints != null) {\n        drawKeypoints(pose.keypoints, ctx, scoreThreshold);\n        // drawSkeleton(pose.keypoints, pose.id);\n    }\n}\n\n/**\n * Draw the keypoints on the video.\n * @param keypoints A list of keypoints.\n */\nfunction drawKeypoints(keypoints, ctx, scoreThreshold) {\n    // Hardcoding MoveNet in\n    const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet)\n    ctx.fillStyle = 'Red';\n    ctx.strokeStyle = 'White';\n    ctx.lineWidth = 2;\n\n    for (const i of keypointInd.middle) {\n        drawKeypoint(keypoints[i], ctx, scoreThreshold);\n    }\n\n    ctx.fillStyle = 'Green';\n    for (const i of keypointInd.left) {\n        drawKeypoint(keypoints[i], ctx, scoreThreshold);\n    }\n\n    ctx.fillStyle = 'Orange';\n    for (const i of keypointInd.right) {\n        drawKeypoint(keypoints[i], ctx, scoreThreshold);\n    }\n}\n\nfunction drawKeypoint(keypoint, ctx, scoreThreshold) {\n    // If score is null, just show the keypoint.\n    const score = keypoint.score != null ? keypoint.score : 1;\n    const minScore = scoreThreshold || 0;\n\n    if (score >= minScore) {\n        const circle = new Path2D();\n        circle.arc(keypoint.x, keypoint.y, 4, 0, 2 * Math.PI);\n        ctx.fill(circle);\n        ctx.stroke(circle);\n    }\n}\n\nexport { drawResults }"]},"metadata":{},"sourceType":"module"}