{"ast":null,"code":"import _createForOfIteratorHelper from\"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";import*as poseDetection from'@tensorflow-models/pose-detection';/**\n * Draw the keypoints and skeleton on the video.\n * @param poses A list of poses to render.\n * @param ctx The context object to draw on\n * @param scoreThreshold The minimum score needed\n */function drawResults(poses,ctx,scoreThreshold){if(!poses)return;var _iterator=_createForOfIteratorHelper(poses),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var pose=_step.value;drawResult(pose,ctx,scoreThreshold);}}catch(err){_iterator.e(err);}finally{_iterator.f();}}/**\n  * Draw the keypoints and skeleton on the video.\n  * @param pose A pose with keypoints to render.\n  */function drawResult(pose,ctx,scoreThreshold){if(pose.keypoints!=null){drawKeypoints(pose.keypoints,ctx,scoreThreshold);// drawSkeleton(pose.keypoints, pose.id);\n}}/**\n * Draw the keypoints on the video.\n * @param keypoints A list of keypoints.\n */function drawKeypoints(keypoints,ctx,scoreThreshold){// Hardcoding MoveNet in\nvar keypointInd=poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet);ctx.fillStyle='Red';ctx.strokeStyle='White';ctx.lineWidth=2;var _iterator2=_createForOfIteratorHelper(keypointInd.middle),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var i=_step2.value;drawKeypoint(keypoints[i],ctx,scoreThreshold);}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}ctx.fillStyle='Green';var _iterator3=_createForOfIteratorHelper(keypointInd.left),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var _i=_step3.value;drawKeypoint(keypoints[_i],ctx,scoreThreshold);}}catch(err){_iterator3.e(err);}finally{_iterator3.f();}ctx.fillStyle='Orange';var _iterator4=_createForOfIteratorHelper(keypointInd.right),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var _i2=_step4.value;drawKeypoint(keypoints[_i2],ctx,scoreThreshold);}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}}function drawKeypoint(keypoint,ctx,scoreThreshold){// If score is null, just show the keypoint.\nvar score=keypoint.score!=null?keypoint.score:1;var minScore=scoreThreshold||0;if(score>=minScore){var circle=new Path2D();circle.arc(keypoint.x,keypoint.y,2,0,2*Math.PI);ctx.fill(circle);ctx.stroke(circle);}}export{drawResults};","map":{"version":3,"sources":["/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/src/utils/drawUtils.js"],"names":["poseDetection","drawResults","poses","ctx","scoreThreshold","pose","drawResult","keypoints","drawKeypoints","keypointInd","util","getKeypointIndexBySide","SupportedModels","MoveNet","fillStyle","strokeStyle","lineWidth","middle","i","drawKeypoint","left","right","keypoint","score","minScore","circle","Path2D","arc","x","y","Math","PI","fill","stroke"],"mappings":"4MAAA,MAAO,GAAKA,CAAAA,aAAZ,KAA+B,mCAA/B,CAEA;AACA;AACA;AACA;AACA;AACA,GACA,QAASC,CAAAA,WAAT,CAAqBC,KAArB,CAA4BC,GAA5B,CAAiCC,cAAjC,CAAiD,CAC7C,GAAI,CAACF,KAAL,CAAY,OADiC,yCAE1BA,KAF0B,YAE7C,+CAA0B,IAAfG,CAAAA,IAAe,aACtBC,UAAU,CAACD,IAAD,CAAOF,GAAP,CAAYC,cAAZ,CAAV,CACH,CAJ4C,qDAKhD,CAED;AACA;AACA;AACA,IACA,QAASE,CAAAA,UAAT,CAAoBD,IAApB,CAA0BF,GAA1B,CAA+BC,cAA/B,CAA+C,CAC3C,GAAIC,IAAI,CAACE,SAAL,EAAkB,IAAtB,CAA4B,CACxBC,aAAa,CAACH,IAAI,CAACE,SAAN,CAAiBJ,GAAjB,CAAsBC,cAAtB,CAAb,CACA;AACH,CACJ,CAED;AACA;AACA;AACA,GACA,QAASI,CAAAA,aAAT,CAAuBD,SAAvB,CAAkCJ,GAAlC,CAAuCC,cAAvC,CAAuD,CACnD;AACA,GAAMK,CAAAA,WAAW,CAAGT,aAAa,CAACU,IAAd,CAAmBC,sBAAnB,CAA0CX,aAAa,CAACY,eAAd,CAA8BC,OAAxE,CAApB,CACAV,GAAG,CAACW,SAAJ,CAAgB,KAAhB,CACAX,GAAG,CAACY,WAAJ,CAAkB,OAAlB,CACAZ,GAAG,CAACa,SAAJ,CAAgB,CAAhB,CALmD,0CAOnCP,WAAW,CAACQ,MAPuB,aAOnD,kDAAoC,IAAzBC,CAAAA,CAAyB,cAChCC,YAAY,CAACZ,SAAS,CAACW,CAAD,CAAV,CAAef,GAAf,CAAoBC,cAApB,CAAZ,CACH,CATkD,uDAWnDD,GAAG,CAACW,SAAJ,CAAgB,OAAhB,CAXmD,0CAYnCL,WAAW,CAACW,IAZuB,aAYnD,kDAAkC,IAAvBF,CAAAA,EAAuB,cAC9BC,YAAY,CAACZ,SAAS,CAACW,EAAD,CAAV,CAAef,GAAf,CAAoBC,cAApB,CAAZ,CACH,CAdkD,uDAgBnDD,GAAG,CAACW,SAAJ,CAAgB,QAAhB,CAhBmD,0CAiBnCL,WAAW,CAACY,KAjBuB,aAiBnD,kDAAmC,IAAxBH,CAAAA,GAAwB,cAC/BC,YAAY,CAACZ,SAAS,CAACW,GAAD,CAAV,CAAef,GAAf,CAAoBC,cAApB,CAAZ,CACH,CAnBkD,uDAoBtD,CAED,QAASe,CAAAA,YAAT,CAAsBG,QAAtB,CAAgCnB,GAAhC,CAAqCC,cAArC,CAAqD,CACjD;AACA,GAAMmB,CAAAA,KAAK,CAAGD,QAAQ,CAACC,KAAT,EAAkB,IAAlB,CAAyBD,QAAQ,CAACC,KAAlC,CAA0C,CAAxD,CACA,GAAMC,CAAAA,QAAQ,CAAGpB,cAAc,EAAI,CAAnC,CAEA,GAAImB,KAAK,EAAIC,QAAb,CAAuB,CACnB,GAAMC,CAAAA,MAAM,CAAG,GAAIC,CAAAA,MAAJ,EAAf,CACAD,MAAM,CAACE,GAAP,CAAWL,QAAQ,CAACM,CAApB,CAAuBN,QAAQ,CAACO,CAAhC,CAAmC,CAAnC,CAAsC,CAAtC,CAAyC,EAAIC,IAAI,CAACC,EAAlD,EACA5B,GAAG,CAAC6B,IAAJ,CAASP,MAAT,EACAtB,GAAG,CAAC8B,MAAJ,CAAWR,MAAX,EACH,CACJ,CAED,OAASxB,WAAT","sourcesContent":["import * as poseDetection from '@tensorflow-models/pose-detection'\n\n/**\n * Draw the keypoints and skeleton on the video.\n * @param poses A list of poses to render.\n * @param ctx The context object to draw on\n * @param scoreThreshold The minimum score needed\n */\nfunction drawResults(poses, ctx, scoreThreshold) {\n    if (!poses) return\n    for (const pose of poses) {\n        drawResult(pose, ctx, scoreThreshold);\n    }\n}\n\n/**\n  * Draw the keypoints and skeleton on the video.\n  * @param pose A pose with keypoints to render.\n  */\nfunction drawResult(pose, ctx, scoreThreshold) {\n    if (pose.keypoints != null) {\n        drawKeypoints(pose.keypoints, ctx, scoreThreshold);\n        // drawSkeleton(pose.keypoints, pose.id);\n    }\n}\n\n/**\n * Draw the keypoints on the video.\n * @param keypoints A list of keypoints.\n */\nfunction drawKeypoints(keypoints, ctx, scoreThreshold) {\n    // Hardcoding MoveNet in\n    const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet)\n    ctx.fillStyle = 'Red';\n    ctx.strokeStyle = 'White';\n    ctx.lineWidth = 2;\n\n    for (const i of keypointInd.middle) {\n        drawKeypoint(keypoints[i], ctx, scoreThreshold);\n    }\n\n    ctx.fillStyle = 'Green';\n    for (const i of keypointInd.left) {\n        drawKeypoint(keypoints[i], ctx, scoreThreshold);\n    }\n\n    ctx.fillStyle = 'Orange';\n    for (const i of keypointInd.right) {\n        drawKeypoint(keypoints[i], ctx, scoreThreshold);\n    }\n}\n\nfunction drawKeypoint(keypoint, ctx, scoreThreshold) {\n    // If score is null, just show the keypoint.\n    const score = keypoint.score != null ? keypoint.score : 1;\n    const minScore = scoreThreshold || 0;\n\n    if (score >= minScore) {\n        const circle = new Path2D();\n        circle.arc(keypoint.x, keypoint.y, 2, 0, 2 * Math.PI);\n        ctx.fill(circle);\n        ctx.stroke(circle);\n    }\n}\n\nexport { drawResults }"]},"metadata":{},"sourceType":"module"}