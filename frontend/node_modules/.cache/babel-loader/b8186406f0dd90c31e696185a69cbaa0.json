{"ast":null,"code":"// import * as poseDetection from '@tensorflow-models/pose-detection'\n// const COLOR_PALETTE = [\n//     '#ffffff', '#800000', '#469990', '#e6194b', '#42d4f4', '#fabed4', '#aaffc3',\n//     '#9a6324', '#000075', '#f58231', '#4363d8', '#ffd8b1', '#dcbeff', '#808000',\n//     '#ffe119', '#911eb4', '#bfef45', '#f032e6', '#3cb44b', '#a9a9a9'\n// ];\n// /**\n//  * Draw the keypoints and skeleton on the video.\n//  * @param poses A list of poses to render.\n//  * @param ctx The context object to draw on\n//  * @param scoreThreshold The minimum score needed\n//  */\n// function drawResults(poses, ctx, scoreThreshold) {\n//     if (!poses || !ctx) return\n//     for (const pose of poses) {\n//         drawResult(pose, ctx, scoreThreshold);\n//     }\n// }\n// /**\n//   * Draw the keypoints and skeleton on the video.\n//   * @param pose A pose with keypoints to render.\n//   */\n// function drawResult(pose, ctx, scoreThreshold) {\n//     if (pose.keypoints != null) {\n//         drawKeypoints(pose.keypoints, ctx, scoreThreshold);\n//         drawSkeleton(pose.keypoints, pose.id, ctx, scoreThreshold);\n//     }\n// }\n// /**\n//  * Draw the keypoints on the video.\n//  * @param keypoints A list of keypoints.\n//  */\n// function drawKeypoints(keypoints, ctx, scoreThreshold) {\n//     // Hardcoding MoveNet in\n//     const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet)\n//     ctx.fillStyle = 'Red';\n//     ctx.strokeStyle = 'White';\n//     ctx.lineWidth = 2;\n//     for (const i of keypointInd.middle) {\n//         drawKeypoint(keypoints[i], ctx, scoreThreshold);\n//     }\n//     ctx.fillStyle = 'Green';\n//     for (const i of keypointInd.left) {\n//         drawKeypoint(keypoints[i], ctx, scoreThreshold);\n//     }\n//     ctx.fillStyle = 'Orange';\n//     for (const i of keypointInd.right) {\n//         drawKeypoint(keypoints[i], ctx, scoreThreshold);\n//     }\n// }\n// function drawKeypoint(keypoint, ctx, scoreThreshold) {\n//     // If score is null, just show the keypoint.\n//     const score = keypoint.score != null ? keypoint.score : 1;\n//     const minScore = scoreThreshold || 0;\n//     if (score >= minScore) {\n//         const circle = new Path2D();\n//         circle.arc(keypoint.x, keypoint.y, 3, 0, 2 * Math.PI);\n//         ctx.fill(circle);\n//         ctx.stroke(circle);\n//     }\n// }\n// /**\n//    * Draw the skeleton of a body on the video.\n//    * @param keypoints A list of keypoints.\n//    * @param poseId The ID of the pose\n//    */\n// function drawSkeleton(keypoints, poseId, ctx, scoreThreshold) {\n//     // Each poseId is mapped to a color in the color palette.\n//     const color = poseId != null ?\n//         COLOR_PALETTE[poseId % 20] :\n//         'White';\n//     ctx.fillStyle = color;\n//     ctx.strokeStyle = color;\n//     ctx.lineWidth = 1;\n//     poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet).forEach(([\n//         i, j\n//     ]) => {\n//         const kp1 = keypoints[i];\n//         const kp2 = keypoints[j];\n//         // If score is null, just show the keypoint.\n//         const score1 = kp1.score != null ? kp1.score : 1;\n//         const score2 = kp2.score != null ? kp2.score : 1;\n//         if (score1 >= scoreThreshold && score2 >= scoreThreshold) {\n//             ctx.beginPath();\n//             ctx.moveTo(kp1.x, kp1.y);\n//             ctx.lineTo(kp2.x, kp2.y);\n//             ctx.stroke();\n//         }\n//     });\n// }\n// export { drawResults }","map":{"version":3,"sources":["/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/src/utils/drawUtils.js"],"names":[],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA","sourcesContent":["// import * as poseDetection from '@tensorflow-models/pose-detection'\n\n// const COLOR_PALETTE = [\n//     '#ffffff', '#800000', '#469990', '#e6194b', '#42d4f4', '#fabed4', '#aaffc3',\n//     '#9a6324', '#000075', '#f58231', '#4363d8', '#ffd8b1', '#dcbeff', '#808000',\n//     '#ffe119', '#911eb4', '#bfef45', '#f032e6', '#3cb44b', '#a9a9a9'\n// ];\n\n// /**\n//  * Draw the keypoints and skeleton on the video.\n//  * @param poses A list of poses to render.\n//  * @param ctx The context object to draw on\n//  * @param scoreThreshold The minimum score needed\n//  */\n// function drawResults(poses, ctx, scoreThreshold) {\n//     if (!poses || !ctx) return\n//     for (const pose of poses) {\n//         drawResult(pose, ctx, scoreThreshold);\n//     }\n// }\n\n// /**\n//   * Draw the keypoints and skeleton on the video.\n//   * @param pose A pose with keypoints to render.\n//   */\n// function drawResult(pose, ctx, scoreThreshold) {\n//     if (pose.keypoints != null) {\n//         drawKeypoints(pose.keypoints, ctx, scoreThreshold);\n//         drawSkeleton(pose.keypoints, pose.id, ctx, scoreThreshold);\n//     }\n// }\n\n// /**\n//  * Draw the keypoints on the video.\n//  * @param keypoints A list of keypoints.\n//  */\n// function drawKeypoints(keypoints, ctx, scoreThreshold) {\n//     // Hardcoding MoveNet in\n//     const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet)\n//     ctx.fillStyle = 'Red';\n//     ctx.strokeStyle = 'White';\n//     ctx.lineWidth = 2;\n\n//     for (const i of keypointInd.middle) {\n//         drawKeypoint(keypoints[i], ctx, scoreThreshold);\n//     }\n\n//     ctx.fillStyle = 'Green';\n//     for (const i of keypointInd.left) {\n//         drawKeypoint(keypoints[i], ctx, scoreThreshold);\n//     }\n\n//     ctx.fillStyle = 'Orange';\n//     for (const i of keypointInd.right) {\n//         drawKeypoint(keypoints[i], ctx, scoreThreshold);\n//     }\n// }\n\n// function drawKeypoint(keypoint, ctx, scoreThreshold) {\n//     // If score is null, just show the keypoint.\n//     const score = keypoint.score != null ? keypoint.score : 1;\n//     const minScore = scoreThreshold || 0;\n\n//     if (score >= minScore) {\n//         const circle = new Path2D();\n//         circle.arc(keypoint.x, keypoint.y, 3, 0, 2 * Math.PI);\n//         ctx.fill(circle);\n//         ctx.stroke(circle);\n//     }\n// }\n\n// /**\n//    * Draw the skeleton of a body on the video.\n//    * @param keypoints A list of keypoints.\n//    * @param poseId The ID of the pose\n//    */\n// function drawSkeleton(keypoints, poseId, ctx, scoreThreshold) {\n//     // Each poseId is mapped to a color in the color palette.\n//     const color = poseId != null ?\n//         COLOR_PALETTE[poseId % 20] :\n//         'White';\n//     ctx.fillStyle = color;\n//     ctx.strokeStyle = color;\n//     ctx.lineWidth = 1;\n\n//     poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet).forEach(([\n//         i, j\n//     ]) => {\n//         const kp1 = keypoints[i];\n//         const kp2 = keypoints[j];\n\n//         // If score is null, just show the keypoint.\n//         const score1 = kp1.score != null ? kp1.score : 1;\n//         const score2 = kp2.score != null ? kp2.score : 1;\n\n//         if (score1 >= scoreThreshold && score2 >= scoreThreshold) {\n//             ctx.beginPath();\n//             ctx.moveTo(kp1.x, kp1.y);\n//             ctx.lineTo(kp2.x, kp2.y);\n//             ctx.stroke();\n//         }\n//     });\n// }\n\n// export { drawResults }"]},"metadata":{},"sourceType":"module"}