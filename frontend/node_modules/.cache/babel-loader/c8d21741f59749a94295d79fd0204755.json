{"ast":null,"code":"import * as poseDetection from '@tensorflow-models/pose-detection';\n/**\n * Draw the keypoints and skeleton on the video.\n * @param poses A list of poses to render.\n * @param ctx The context object to draw on\n * @param scoreThreshold The minimum score needed\n */\n\nfunction drawResults(poses, ctx, scoreThreshold) {\n  for (const pose of poses) {\n    drawResult(pose, ctx, scoreThreshold);\n  }\n}\n/**\n  * Draw the keypoints and skeleton on the video.\n  * @param pose A pose with keypoints to render.\n  */\n\n\nfunction drawResult(pose, ctx, scoreThreshold) {\n  if (pose.keypoints != null) {\n    drawKeypoints(pose.keypoints, ctx, scoreThreshold); // drawSkeleton(pose.keypoints, pose.id);\n  }\n}\n/**\n * Draw the keypoints on the video.\n * @param keypoints A list of keypoints.\n */\n\n\nfunction drawKeypoints(keypoints, ctx, scoreThreshold) {\n  // Hardcoding MoveNet in\n  const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet);\n  ctx.fillStyle = 'Red';\n  ctx.strokeStyle = 'White';\n  ctx.lineWidth = 2;\n\n  for (const i of keypointInd.middle) {\n    drawKeypoint(keypoints[i]);\n  }\n\n  ctx.fillStyle = 'Green';\n\n  for (const i of keypointInd.left) {\n    drawKeypoint(keypoints[i]);\n  }\n\n  ctx.fillStyle = 'Orange';\n\n  for (const i of keypointInd.right) {\n    drawKeypoint(keypoints[i]);\n  }\n}\n\nfunction drawKeypoint(keypoint, ctx, scoreThreshold) {\n  // If score is null, just show the keypoint.\n  const score = keypoint.score != null ? keypoint.score : 1;\n  const minScore = scoreThreshold || 0;\n\n  if (score >= minScore) {\n    const circle = new Path2D();\n    circle.arc(keypoint.x, keypoint.y, params.DEFAULT_RADIUS, 0, 2 * Math.PI);\n    ctx.fill(circle);\n    ctx.stroke(circle);\n  }\n}\n\nexport { drawResults };","map":{"version":3,"sources":["/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/src/utils/drawUtils.js"],"names":["poseDetection","drawResults","poses","ctx","scoreThreshold","pose","drawResult","keypoints","drawKeypoints","keypointInd","util","getKeypointIndexBySide","SupportedModels","MoveNet","fillStyle","strokeStyle","lineWidth","i","middle","drawKeypoint","left","right","keypoint","score","minScore","circle","Path2D","arc","x","y","params","DEFAULT_RADIUS","Math","PI","fill","stroke"],"mappings":"AAAA,OAAO,KAAKA,aAAZ,MAA+B,mCAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,GAA5B,EAAiCC,cAAjC,EAAiD;AAC7C,OAAK,MAAMC,IAAX,IAAmBH,KAAnB,EAA0B;AACtBI,IAAAA,UAAU,CAACD,IAAD,EAAOF,GAAP,EAAYC,cAAZ,CAAV;AACH;AACJ;AAED;AACA;AACA;AACA;;;AACA,SAASE,UAAT,CAAoBD,IAApB,EAA0BF,GAA1B,EAA+BC,cAA/B,EAA+C;AAC3C,MAAIC,IAAI,CAACE,SAAL,IAAkB,IAAtB,EAA4B;AACxBC,IAAAA,aAAa,CAACH,IAAI,CAACE,SAAN,EAAiBJ,GAAjB,EAAsBC,cAAtB,CAAb,CADwB,CAExB;AACH;AACJ;AAED;AACA;AACA;AACA;;;AACA,SAASI,aAAT,CAAuBD,SAAvB,EAAkCJ,GAAlC,EAAuCC,cAAvC,EAAuD;AACnD;AACA,QAAMK,WAAW,GAAGT,aAAa,CAACU,IAAd,CAAmBC,sBAAnB,CAA0CX,aAAa,CAACY,eAAd,CAA8BC,OAAxE,CAApB;AACAV,EAAAA,GAAG,CAACW,SAAJ,GAAgB,KAAhB;AACAX,EAAAA,GAAG,CAACY,WAAJ,GAAkB,OAAlB;AACAZ,EAAAA,GAAG,CAACa,SAAJ,GAAgB,CAAhB;;AAEA,OAAK,MAAMC,CAAX,IAAgBR,WAAW,CAACS,MAA5B,EAAoC;AAChCC,IAAAA,YAAY,CAACZ,SAAS,CAACU,CAAD,CAAV,CAAZ;AACH;;AAEDd,EAAAA,GAAG,CAACW,SAAJ,GAAgB,OAAhB;;AACA,OAAK,MAAMG,CAAX,IAAgBR,WAAW,CAACW,IAA5B,EAAkC;AAC9BD,IAAAA,YAAY,CAACZ,SAAS,CAACU,CAAD,CAAV,CAAZ;AACH;;AAEDd,EAAAA,GAAG,CAACW,SAAJ,GAAgB,QAAhB;;AACA,OAAK,MAAMG,CAAX,IAAgBR,WAAW,CAACY,KAA5B,EAAmC;AAC/BF,IAAAA,YAAY,CAACZ,SAAS,CAACU,CAAD,CAAV,CAAZ;AACH;AACJ;;AAED,SAASE,YAAT,CAAsBG,QAAtB,EAAgCnB,GAAhC,EAAqCC,cAArC,EAAqD;AACjD;AACA,QAAMmB,KAAK,GAAGD,QAAQ,CAACC,KAAT,IAAkB,IAAlB,GAAyBD,QAAQ,CAACC,KAAlC,GAA0C,CAAxD;AACA,QAAMC,QAAQ,GAAGpB,cAAc,IAAI,CAAnC;;AAEA,MAAImB,KAAK,IAAIC,QAAb,EAAuB;AACnB,UAAMC,MAAM,GAAG,IAAIC,MAAJ,EAAf;AACAD,IAAAA,MAAM,CAACE,GAAP,CAAWL,QAAQ,CAACM,CAApB,EAAuBN,QAAQ,CAACO,CAAhC,EAAmCC,MAAM,CAACC,cAA1C,EAA0D,CAA1D,EAA6D,IAAIC,IAAI,CAACC,EAAtE;AACA9B,IAAAA,GAAG,CAAC+B,IAAJ,CAAST,MAAT;AACAtB,IAAAA,GAAG,CAACgC,MAAJ,CAAWV,MAAX;AACH;AACJ;;AAED,SAASxB,WAAT","sourcesContent":["import * as poseDetection from '@tensorflow-models/pose-detection'\n\n/**\n * Draw the keypoints and skeleton on the video.\n * @param poses A list of poses to render.\n * @param ctx The context object to draw on\n * @param scoreThreshold The minimum score needed\n */\nfunction drawResults(poses, ctx, scoreThreshold) {\n    for (const pose of poses) {\n        drawResult(pose, ctx, scoreThreshold);\n    }\n}\n\n/**\n  * Draw the keypoints and skeleton on the video.\n  * @param pose A pose with keypoints to render.\n  */\nfunction drawResult(pose, ctx, scoreThreshold) {\n    if (pose.keypoints != null) {\n        drawKeypoints(pose.keypoints, ctx, scoreThreshold);\n        // drawSkeleton(pose.keypoints, pose.id);\n    }\n}\n\n/**\n * Draw the keypoints on the video.\n * @param keypoints A list of keypoints.\n */\nfunction drawKeypoints(keypoints, ctx, scoreThreshold) {\n    // Hardcoding MoveNet in\n    const keypointInd = poseDetection.util.getKeypointIndexBySide(poseDetection.SupportedModels.MoveNet)\n    ctx.fillStyle = 'Red';\n    ctx.strokeStyle = 'White';\n    ctx.lineWidth = 2;\n\n    for (const i of keypointInd.middle) {\n        drawKeypoint(keypoints[i]);\n    }\n\n    ctx.fillStyle = 'Green';\n    for (const i of keypointInd.left) {\n        drawKeypoint(keypoints[i]);\n    }\n\n    ctx.fillStyle = 'Orange';\n    for (const i of keypointInd.right) {\n        drawKeypoint(keypoints[i]);\n    }\n}\n\nfunction drawKeypoint(keypoint, ctx, scoreThreshold) {\n    // If score is null, just show the keypoint.\n    const score = keypoint.score != null ? keypoint.score : 1;\n    const minScore = scoreThreshold || 0;\n\n    if (score >= minScore) {\n        const circle = new Path2D();\n        circle.arc(keypoint.x, keypoint.y, params.DEFAULT_RADIUS, 0, 2 * Math.PI);\n        ctx.fill(circle);\n        ctx.stroke(circle);\n    }\n}\n\nexport { drawResults }"]},"metadata":{},"sourceType":"module"}