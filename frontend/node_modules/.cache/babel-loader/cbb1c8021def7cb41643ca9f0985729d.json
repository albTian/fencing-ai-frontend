{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, Concat, util } from '@tensorflow/tfjs-core';\nimport { concatImplCPU } from '../kernel_utils/shared';\nimport { identity } from './Identity';\nimport { reshape } from './Reshape';\nexport function concat(args) {\n  const {\n    inputs,\n    backend\n  } = args;\n  const axis = util.parseAxisParam(args.attrs.axis, inputs[0].shape)[0];\n  let outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis); // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n\n  if ($inputs.length === 1) {\n    return identity({\n      inputs: {\n        x: $inputs[0]\n      },\n      backend\n    });\n  }\n\n  const out = backend.makeOutput(outShape, inputs[0].dtype);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return out;\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, axis);\n\n  if ($inputs[0].dtype === 'string') {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const inputs2D = $inputs.map(t => {\n      const innerSize = util.sizeFromShape(t.shape.slice(axis));\n      const shape = [-1, innerSize];\n      return reshape({\n        inputs: {\n          x: t\n        },\n        backend,\n        attrs: {\n          shape\n        }\n      });\n    });\n    const inputsValShapes = inputs2D.map(t => {\n      return {\n        vals: backend.readSync(t.dataId),\n        shape: t.shape\n      };\n    }); // Concats 2d tensors along axis=1.\n\n    outShape = backend_util.computeOutShape(inputs2D.map(t => t.shape), 1\n    /* axis */\n    );\n    const simplyConcat = inputs2D[0].shape[0] === 1;\n    const outVals = concatImplCPU(inputsValShapes, outShape, inputs[0].dtype, simplyConcat);\n    const finalOutShape = backend_util.computeOutShape($inputs.map(t => t.shape), axis);\n    out.shape = finalOutShape;\n    const outData = backend.dataIdMap.get(out.dataId);\n    outData.stringBytes = backend_util.fromStringArrayToUint8(outVals);\n    inputs2D.forEach(t => backend.disposeData(t.dataId));\n    return out;\n  }\n\n  const batchDim = util.sizeFromShape($inputs[0].shape.slice(0, axis));\n  let sumInnerDims = 0;\n  const innerDims = $inputs.map(input => {\n    const innerDim = util.sizeFromShape(input.shape.slice(axis));\n    sumInnerDims += innerDim;\n    return innerDim;\n  });\n  const inVals = $inputs.map(input => backend.typedArrayFromHeap(input));\n  const outVals = backend.typedArrayFromHeap(out);\n\n  for (let b = 0; b < batchDim; b++) {\n    let outOffset = b * sumInnerDims;\n\n    for (let i = 0; i < inVals.length; i++) {\n      const innerDim = innerDims[i];\n      const inOffset = b * innerDim;\n      const vals = inVals[i].subarray(inOffset, inOffset + innerDim);\n      outVals.set(vals, outOffset);\n      outOffset += innerDim;\n    }\n  }\n\n  return out;\n}\nexport const concatConfig = {\n  kernelName: Concat,\n  backendName: 'wasm',\n  kernelFunc: concat\n};","map":{"version":3,"sources":["../../src/kernels/Concat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\nimport {concatImplCPU} from '../kernel_utils/shared';\nimport {identity} from './Identity';\nimport {reshape} from './Reshape';\n\nexport function concat(\n    args: {inputs: ConcatInputs, backend: BackendWasm, attrs: ConcatAttrs}) {\n  const {inputs, backend} = args;\n\n  const axis = util.parseAxisParam(args.attrs.axis, inputs[0].shape)[0];\n\n  let outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({inputs: {x: $inputs[0]}, backend});\n  }\n\n  const out = backend.makeOutput(outShape, inputs[0].dtype);\n\n  if (util.sizeFromShape(outShape) === 0) {\n    return out;\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, axis);\n\n  if ($inputs[0].dtype === 'string') {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const inputs2D = $inputs.map(t => {\n      const innerSize = util.sizeFromShape(t.shape.slice(axis));\n      const shape = [-1, innerSize];\n      return reshape({inputs: {x: t}, backend, attrs: {shape}});\n    });\n\n    const inputsValShapes = inputs2D.map(t => {\n      return {vals: backend.readSync(t.dataId), shape: t.shape};\n    });\n\n    // Concats 2d tensors along axis=1.\n    outShape =\n        backend_util.computeOutShape(inputs2D.map(t => t.shape), 1 /* axis */);\n    const simplyConcat = inputs2D[0].shape[0] === 1;\n    const outVals = concatImplCPU(\n                        inputsValShapes, outShape, inputs[0].dtype,\n                        simplyConcat) as string[];\n\n    const finalOutShape =\n        backend_util.computeOutShape($inputs.map(t => t.shape), axis);\n\n    out.shape = finalOutShape;\n    const outData = backend.dataIdMap.get(out.dataId);\n    outData.stringBytes = backend_util.fromStringArrayToUint8(outVals);\n\n    inputs2D.forEach(t => backend.disposeData(t.dataId));\n\n    return out;\n  }\n\n  const batchDim = util.sizeFromShape($inputs[0].shape.slice(0, axis));\n  let sumInnerDims = 0;\n  const innerDims = $inputs.map(input => {\n    const innerDim = util.sizeFromShape(input.shape.slice(axis));\n    sumInnerDims += innerDim;\n    return innerDim;\n  });\n  const inVals = $inputs.map(input => backend.typedArrayFromHeap(input));\n  const outVals = backend.typedArrayFromHeap(out);\n  for (let b = 0; b < batchDim; b++) {\n    let outOffset = b * sumInnerDims;\n    for (let i = 0; i < inVals.length; i++) {\n      const innerDim = innerDims[i];\n      const inOffset = b * innerDim;\n      const vals = inVals[i].subarray(inOffset, inOffset + innerDim);\n      outVals.set(vals, outOffset);\n      outOffset += innerDim;\n    }\n  }\n  return out;\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'wasm',\n  kernelFunc: concat as {} as KernelFunc,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}