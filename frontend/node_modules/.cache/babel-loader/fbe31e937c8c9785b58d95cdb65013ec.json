{"ast":null,"code":"import _regeneratorRuntime from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext, setWebGLContext } from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport * as webgl_util from './webgl_util';\nexport var GPGPUContext = /*#__PURE__*/function () {\n  function GPGPUContext(gl) {\n    _classCallCheck(this, GPGPUContext);\n\n    this.outputTexture = null;\n    this.program = null;\n    this.disposed = false;\n    this.vertexAttrsAreBound = false;\n    this.itemsToPoll = [];\n    var glVersion = env().getNumber('WEBGL_VERSION');\n\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    } // WebGL 2.0 enables texture floats without an extension.\n\n\n    var COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    var COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      var TEXTURE_FLOAT = 'OES_texture_float';\n      var TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n      this.textureFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support half float textures, yet the ' + 'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error('GL context does not support color renderable half floats, yet ' + 'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension = this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n    this.textureConfig = tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  _createClass(GPGPUContext, [{\n    key: \"debug\",\n    get: function get() {\n      return env().getBool('DEBUG');\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this = this;\n\n      if (this.disposed) {\n        return;\n      }\n\n      if (this.program != null) {\n        console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' + ' This is probably a resource leak, delete the program with ' + 'GPGPUContext.deleteProgram before disposing.');\n      }\n\n      if (this.outputTexture != null) {\n        console.warn('Disposing a GPGPUContext that still has a bound output matrix ' + 'texture.  This is probably a resource leak, delete the output ' + 'matrix texture with GPGPUContext.deleteMatrixTexture before ' + 'disposing.');\n      }\n\n      var gl = this.gl;\n      webgl_util.callAndCheck(gl, function () {\n        return gl.finish();\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.deleteFramebuffer(_this.framebuffer);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.bindBuffer(gl.ARRAY_BUFFER, null);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.deleteBuffer(_this.indexBuffer);\n      });\n      this.disposed = true;\n    }\n  }, {\n    key: \"createFloat32MatrixTexture\",\n    value: function createFloat32MatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createFloat32MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"createFloat16MatrixTexture\",\n    value: function createFloat16MatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createFloat16MatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"createUnsignedBytesMatrixTexture\",\n    value: function createUnsignedBytesMatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createUnsignedBytesMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"uploadPixelDataToTexture\",\n    value: function uploadPixelDataToTexture(texture, pixels) {\n      this.throwIfDisposed();\n      gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n    }\n  }, {\n    key: \"uploadDenseMatrixToTexture\",\n    value: function uploadDenseMatrixToTexture(texture, width, height, data) {\n      this.throwIfDisposed();\n      gpgpu_util.uploadDenseMatrixToTexture(this.gl, texture, width, height, data, this.textureConfig);\n    }\n  }, {\n    key: \"createFloat16PackedMatrixTexture\",\n    value: function createFloat16PackedMatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createFloat16PackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"createPackedMatrixTexture\",\n    value: function createPackedMatrixTexture(rows, columns) {\n      this.throwIfDisposed();\n      return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns, this.textureConfig);\n    }\n  }, {\n    key: \"deleteMatrixTexture\",\n    value: function deleteMatrixTexture(texture) {\n      var _this2 = this;\n\n      this.throwIfDisposed();\n\n      if (this.outputTexture === texture) {\n        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n        this.outputTexture = null;\n      }\n\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this2.gl.deleteTexture(texture);\n      });\n    }\n  }, {\n    key: \"downloadByteEncodedFloatMatrixFromOutputTexture\",\n    value: function downloadByteEncodedFloatMatrixFromOutputTexture(texture, rows, columns) {\n      var _this3 = this;\n\n      return this.downloadMatrixDriver(texture, function () {\n        return gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(_this3.gl, rows, columns, _this3.textureConfig);\n      });\n    }\n  }, {\n    key: \"downloadPackedMatrixFromBuffer\",\n    value: function downloadPackedMatrixFromBuffer(buffer, batch, rows, columns, physicalRows, physicalCols) {\n      return gpgpu_util.downloadPackedMatrixFromBuffer(this.gl, buffer, batch, rows, columns, physicalRows, physicalCols, this.textureConfig);\n    }\n  }, {\n    key: \"downloadFloat32MatrixFromBuffer\",\n    value: function downloadFloat32MatrixFromBuffer(buffer, size) {\n      return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n    }\n  }, {\n    key: \"createBufferFromTexture\",\n    value: function createBufferFromTexture(texture, rows, columns) {\n      this.bindTextureToFrameBuffer(texture);\n      var result = gpgpu_util.createBufferFromOutputTexture(this.gl, rows, columns, this.textureConfig);\n      this.unbindTextureToFrameBuffer();\n      return result;\n    }\n  }, {\n    key: \"createAndWaitForFence\",\n    value: function createAndWaitForFence() {\n      var fenceContext = this.createFence(this.gl);\n      return this.pollFence(fenceContext);\n    }\n  }, {\n    key: \"createFence\",\n    value: function createFence(gl) {\n      var _this4 = this;\n\n      var query;\n      var isFencePassed;\n\n      if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n        var gl2 = gl;\n        var sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n        gl.flush();\n\n        isFencePassed = function isFencePassed() {\n          var status = gl2.clientWaitSync(sync, 0, 0);\n          return status === gl2.ALREADY_SIGNALED || status === gl2.CONDITION_SATISFIED;\n        };\n\n        query = sync;\n      } else if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n        query = this.beginQuery();\n        this.endQuery();\n\n        isFencePassed = function isFencePassed() {\n          return _this4.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n        };\n      } else {\n        // If we have no way to fence, return true immediately. This will fire in\n        // WebGL 1.0 when there is no disjoint query timer. In this case, because\n        // the fence passes immediately, we'll immediately ask for a download of\n        // the texture, which will cause the UI thread to hang.\n        isFencePassed = function isFencePassed() {\n          return true;\n        };\n      }\n\n      return {\n        query: query,\n        isFencePassed: isFencePassed\n      };\n    }\n  }, {\n    key: \"downloadMatrixFromPackedTexture\",\n    value: function downloadMatrixFromPackedTexture(texture, physicalRows, physicalCols) {\n      var _this5 = this;\n\n      return this.downloadMatrixDriver(texture, function () {\n        return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this5.gl, physicalRows, physicalCols);\n      });\n    }\n  }, {\n    key: \"createProgram\",\n    value: function createProgram(fragmentShaderSource) {\n      var _this6 = this;\n\n      this.throwIfDisposed();\n      var gl = this.gl;\n      var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);\n\n      if (this.vertexShader == null) {\n        this.vertexShader = gpgpu_util.createVertexShader(gl);\n      }\n\n      var program = webgl_util.createProgram(gl);\n      webgl_util.callAndCheck(gl, function () {\n        return gl.attachShader(program, _this6.vertexShader);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.attachShader(program, fragmentShader);\n      });\n      webgl_util.linkProgram(gl, program);\n\n      if (this.debug) {\n        webgl_util.validateProgram(gl, program);\n      }\n\n      if (!this.vertexAttrsAreBound) {\n        this.setProgram(program);\n        this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);\n      }\n\n      return program;\n    }\n  }, {\n    key: \"deleteProgram\",\n    value: function deleteProgram(program) {\n      var _this7 = this;\n\n      this.throwIfDisposed();\n\n      if (program === this.program) {\n        this.program = null;\n      }\n\n      if (program != null) {\n        webgl_util.callAndCheck(this.gl, function () {\n          return _this7.gl.deleteProgram(program);\n        });\n      }\n    }\n  }, {\n    key: \"setProgram\",\n    value: function setProgram(program) {\n      var _this8 = this;\n\n      this.throwIfDisposed();\n      this.program = program;\n\n      if (this.program != null && this.debug) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this8.gl.useProgram(program);\n      });\n    }\n  }, {\n    key: \"getUniformLocation\",\n    value: function getUniformLocation(program, uniformName) {\n      var shouldThrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      this.throwIfDisposed();\n\n      if (shouldThrow) {\n        return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);\n      } else {\n        return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);\n      }\n    }\n  }, {\n    key: \"getAttributeLocation\",\n    value: function getAttributeLocation(program, attribute) {\n      var _this9 = this;\n\n      this.throwIfDisposed();\n      return webgl_util.callAndCheck(this.gl, function () {\n        return _this9.gl.getAttribLocation(program, attribute);\n      });\n    }\n  }, {\n    key: \"getUniformLocationNoThrow\",\n    value: function getUniformLocationNoThrow(program, uniformName) {\n      this.throwIfDisposed();\n      return this.gl.getUniformLocation(program, uniformName);\n    }\n  }, {\n    key: \"setInputMatrixTexture\",\n    value: function setInputMatrixTexture(inputMatrixTexture, uniformLocation, textureUnit) {\n      this.throwIfDisposed();\n      this.throwIfNoProgram();\n      webgl_util.bindTextureToProgramUniformSampler(this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n    }\n  }, {\n    key: \"setOutputMatrixTexture\",\n    value: function setOutputMatrixTexture(outputMatrixTexture, rows, columns) {\n      this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n    }\n  }, {\n    key: \"setOutputPackedMatrixTexture\",\n    value: function setOutputPackedMatrixTexture(outputPackedMatrixTexture, rows, columns) {\n      this.throwIfDisposed();\n\n      var _tex_util$getPackedMa = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns),\n          _tex_util$getPackedMa2 = _slicedToArray(_tex_util$getPackedMa, 2),\n          width = _tex_util$getPackedMa2[0],\n          height = _tex_util$getPackedMa2[1];\n\n      this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n    }\n  }, {\n    key: \"setOutputMatrixWriteRegion\",\n    value: function setOutputMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n      this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);\n    }\n  }, {\n    key: \"setOutputPackedMatrixWriteRegion\",\n    value: function setOutputPackedMatrixWriteRegion(startRow, numRows, startColumn, numColumns) {\n      throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n    }\n  }, {\n    key: \"debugValidate\",\n    value: function debugValidate() {\n      if (this.program != null) {\n        webgl_util.validateProgram(this.gl, this.program);\n      }\n\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }, {\n    key: \"executeProgram\",\n    value: function executeProgram() {\n      this.throwIfDisposed();\n      this.throwIfNoProgram();\n      var gl = this.gl;\n\n      if (this.debug) {\n        this.debugValidate();\n      }\n\n      webgl_util.callAndCheck(gl, function () {\n        return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n      });\n    }\n  }, {\n    key: \"blockUntilAllProgramsCompleted\",\n    value: function blockUntilAllProgramsCompleted() {\n      var _this10 = this;\n\n      this.throwIfDisposed();\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this10.gl.finish();\n      });\n    }\n  }, {\n    key: \"getQueryTimerExtension\",\n    value: function getQueryTimerExtension() {\n      if (this.disjointQueryTimerExtension == null) {\n        this.disjointQueryTimerExtension = webgl_util.getExtensionOrThrow(this.gl, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ? 'EXT_disjoint_timer_query_webgl2' : 'EXT_disjoint_timer_query');\n      }\n\n      return this.disjointQueryTimerExtension;\n    }\n  }, {\n    key: \"getQueryTimerExtensionWebGL2\",\n    value: function getQueryTimerExtensionWebGL2() {\n      return this.getQueryTimerExtension();\n    }\n  }, {\n    key: \"getQueryTimerExtensionWebGL1\",\n    value: function getQueryTimerExtensionWebGL1() {\n      return this.getQueryTimerExtension();\n    }\n  }, {\n    key: \"beginQuery\",\n    value: function beginQuery() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n        var gl2 = this.gl;\n\n        var _ext = this.getQueryTimerExtensionWebGL2();\n\n        var _query = gl2.createQuery();\n\n        gl2.beginQuery(_ext.TIME_ELAPSED_EXT, _query);\n        return _query;\n      }\n\n      var ext = this.getQueryTimerExtensionWebGL1();\n      var query = ext.createQueryEXT();\n      ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n  }, {\n    key: \"endQuery\",\n    value: function endQuery() {\n      if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n        var gl2 = this.gl;\n\n        var _ext2 = this.getQueryTimerExtensionWebGL2();\n\n        gl2.endQuery(_ext2.TIME_ELAPSED_EXT);\n        return;\n      }\n\n      var ext = this.getQueryTimerExtensionWebGL1();\n      ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n    }\n  }, {\n    key: \"waitForQueryAndGetTime\",\n    value: function () {\n      var _waitForQueryAndGetTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(query) {\n        var _this11 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return util.repeatedTry(function () {\n                  return _this11.disposed || // while testing contexts are created / disposed\n                  // in rapid succession, so without this check we\n                  // may poll for the query timer indefinitely\n                  _this11.isQueryAvailable(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n                });\n\n              case 2:\n                return _context.abrupt(\"return\", this.getQueryTime(query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function waitForQueryAndGetTime(_x) {\n        return _waitForQueryAndGetTime.apply(this, arguments);\n      }\n\n      return waitForQueryAndGetTime;\n    }()\n  }, {\n    key: \"getQueryTime\",\n    value: function getQueryTime(query, queryTimerVersion) {\n      if (queryTimerVersion === 0) {\n        return null;\n      }\n\n      if (queryTimerVersion === 2) {\n        var gl2 = this.gl;\n        var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT); // Return milliseconds.\n\n        return timeElapsedNanos / 1000000;\n      } else {\n        var ext = this.getQueryTimerExtensionWebGL1();\n\n        var _timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT); // Return milliseconds.\n\n\n        return _timeElapsedNanos / 1000000;\n      }\n    }\n  }, {\n    key: \"isQueryAvailable\",\n    value: function isQueryAvailable(query, queryTimerVersion) {\n      if (queryTimerVersion === 0) {\n        return true;\n      }\n\n      if (queryTimerVersion === 2) {\n        var gl2 = this.gl;\n        var ext = this.getQueryTimerExtensionWebGL2();\n        var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n\n        if (this.disjoint == null) {\n          this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n        }\n\n        return available && !this.disjoint;\n      } else {\n        var _ext3 = this.getQueryTimerExtensionWebGL1();\n\n        var _available = _ext3.getQueryObjectEXT(query, _ext3.QUERY_RESULT_AVAILABLE_EXT);\n\n        if (this.disjoint == null) {\n          this.disjoint = this.gl.getParameter(_ext3.GPU_DISJOINT_EXT);\n        }\n\n        return _available && !this.disjoint;\n      }\n    }\n  }, {\n    key: \"pollFence\",\n    value: function pollFence(fenceContext) {\n      var _this12 = this;\n\n      return new Promise(function (resolve) {\n        _this12.addItemToPoll(function () {\n          return fenceContext.isFencePassed();\n        }, function () {\n          return resolve();\n        });\n      });\n    }\n  }, {\n    key: \"pollItems\",\n    value: function pollItems() {\n      // Find the last query that has finished.\n      var index = linearSearchLastTrue(this.itemsToPoll.map(function (x) {\n        return x.isDoneFn;\n      }));\n\n      for (var i = 0; i <= index; ++i) {\n        var resolveFn = this.itemsToPoll[i].resolveFn;\n        resolveFn();\n      }\n\n      this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n    }\n  }, {\n    key: \"addItemToPoll\",\n    value: function addItemToPoll(isDoneFn, resolveFn) {\n      var _this13 = this;\n\n      this.itemsToPoll.push({\n        isDoneFn: isDoneFn,\n        resolveFn: resolveFn\n      });\n\n      if (this.itemsToPoll.length > 1) {\n        // We already have a running loop that polls.\n        return;\n      } // Start a new loop that polls.\n\n\n      util.repeatedTry(function () {\n        _this13.pollItems(); // End the loop if no more items to poll.\n\n\n        return _this13.itemsToPoll.length === 0;\n      });\n    }\n  }, {\n    key: \"bindTextureToFrameBuffer\",\n    value: function bindTextureToFrameBuffer(texture) {\n      this.throwIfDisposed();\n      webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    }\n  }, {\n    key: \"unbindTextureToFrameBuffer\",\n    value: function unbindTextureToFrameBuffer() {\n      if (this.outputTexture != null) {\n        webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);\n\n        if (this.debug) {\n          webgl_util.validateFramebuffer(this.gl);\n        }\n      } else {\n        webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      }\n    }\n  }, {\n    key: \"downloadMatrixDriver\",\n    value: function downloadMatrixDriver(texture, downloadAndDecode) {\n      this.bindTextureToFrameBuffer(texture);\n      var result = downloadAndDecode();\n      this.unbindTextureToFrameBuffer();\n      return result;\n    }\n  }, {\n    key: \"setOutputMatrixTextureDriver\",\n    value: function setOutputMatrixTextureDriver(outputMatrixTextureMaybePacked, width, height) {\n      this.throwIfDisposed();\n      var gl = this.gl;\n      webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);\n\n      if (this.debug) {\n        webgl_util.validateFramebuffer(gl);\n      }\n\n      this.outputTexture = outputMatrixTextureMaybePacked;\n      webgl_util.callAndCheck(gl, function () {\n        return gl.viewport(0, 0, width, height);\n      });\n      webgl_util.callAndCheck(gl, function () {\n        return gl.scissor(0, 0, width, height);\n      });\n    }\n  }, {\n    key: \"setOutputMatrixWriteRegionDriver\",\n    value: function setOutputMatrixWriteRegionDriver(x, y, width, height) {\n      var _this14 = this;\n\n      this.throwIfDisposed();\n      webgl_util.callAndCheck(this.gl, function () {\n        return _this14.gl.scissor(x, y, width, height);\n      });\n    }\n  }, {\n    key: \"throwIfDisposed\",\n    value: function throwIfDisposed() {\n      if (this.disposed) {\n        throw new Error('Attempted to use disposed GPGPUContext.');\n      }\n    }\n  }, {\n    key: \"throwIfNoProgram\",\n    value: function throwIfNoProgram() {\n      if (this.program == null) {\n        throw new Error('No GPU program is currently set.');\n      }\n    }\n  }]);\n\n  return GPGPUContext;\n}();\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\n\nexport function linearSearchLastTrue(arr) {\n  var i = 0;\n\n  for (; i < arr.length; ++i) {\n    var isDone = arr[i]();\n\n    if (!isDone) {\n      break;\n    }\n  }\n\n  return i - 1;\n}","map":{"version":3,"sources":["../src/gpgpu_context.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, PixelData, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext, setWebGLContext} from './canvas_util';\nimport * as gpgpu_util from './gpgpu_util';\nimport * as tex_util from './tex_util';\nimport {TextureConfig} from './tex_util';\nimport {WebGL1DisjointQueryTimerExtension, WebGL2DisjointQueryTimerExtension} from './webgl_types';\nimport * as webgl_util from './webgl_util';\n\nexport interface FenceContext {\n  query: WebGLQuery|WebGLSync;\n  isFencePassed(): boolean;\n}\n\nexport class GPGPUContext {\n  gl: WebGLRenderingContext;\n  textureFloatExtension: {};\n  textureHalfFloatExtension: {};\n  colorBufferFloatExtension: {};\n  colorBufferHalfFloatExtension: {};\n  disjointQueryTimerExtension: WebGL2DisjointQueryTimerExtension|\n      WebGL1DisjointQueryTimerExtension;\n  vertexBuffer: WebGLBuffer;\n  indexBuffer: WebGLBuffer;\n  framebuffer: WebGLFramebuffer;\n  outputTexture: WebGLTexture|null = null;\n  program: WebGLProgram|null = null;\n  private disposed = false;\n  private disjoint: boolean;\n  private vertexShader: WebGLShader;\n  textureConfig: TextureConfig;\n\n  constructor(gl?: WebGLRenderingContext) {\n    const glVersion = env().getNumber('WEBGL_VERSION');\n    if (gl != null) {\n      this.gl = gl;\n      setWebGLContext(glVersion, gl);\n    } else {\n      this.gl = getWebGLContext(glVersion);\n    }\n    // WebGL 2.0 enables texture floats without an extension.\n    let COLOR_BUFFER_FLOAT = 'WEBGL_color_buffer_float';\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (env().getNumber('WEBGL_VERSION') === 1) {\n      const TEXTURE_FLOAT = 'OES_texture_float';\n      const TEXTURE_HALF_FLOAT = 'OES_texture_half_float';\n\n      this.textureFloatExtension =\n          webgl_util.getExtensionOrThrow(this.gl, TEXTURE_FLOAT);\n      if (webgl_util.hasExtension(this.gl, TEXTURE_HALF_FLOAT)) {\n        this.textureHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, TEXTURE_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support half float textures, yet the ' +\n            'environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n\n      this.colorBufferFloatExtension = this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            webgl_util.getExtensionOrThrow(this.gl, COLOR_BUFFER_HALF_FLOAT);\n      } else if (env().get('WEBGL_FORCE_F16_TEXTURES')) {\n        throw new Error(\n            'GL context does not support color renderable half floats, yet ' +\n            'the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.');\n      }\n    } else {\n      COLOR_BUFFER_FLOAT = 'EXT_color_buffer_float';\n      if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_FLOAT)) {\n        this.colorBufferFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_FLOAT);\n      } else if (webgl_util.hasExtension(this.gl, COLOR_BUFFER_HALF_FLOAT)) {\n        this.colorBufferHalfFloatExtension =\n            this.gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      } else {\n        throw new Error('GL context does not support color renderable floats');\n      }\n    }\n\n    this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);\n    this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);\n    this.framebuffer = webgl_util.createFramebuffer(this.gl);\n\n    this.textureConfig =\n        tex_util.getTextureConfig(this.gl, this.textureHalfFloatExtension);\n  }\n\n  private get debug(): boolean {\n    return env().getBool('DEBUG');\n  }\n\n  public dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.program != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound WebGLProgram.' +\n          ' This is probably a resource leak, delete the program with ' +\n          'GPGPUContext.deleteProgram before disposing.');\n    }\n    if (this.outputTexture != null) {\n      console.warn(\n          'Disposing a GPGPUContext that still has a bound output matrix ' +\n          'texture.  This is probably a resource leak, delete the output ' +\n          'matrix texture with GPGPUContext.deleteMatrixTexture before ' +\n          'disposing.');\n    }\n    const gl = this.gl;\n    webgl_util.callAndCheck(gl, () => gl.finish());\n    webgl_util.callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteFramebuffer(this.framebuffer));\n    webgl_util.callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(\n        gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null));\n    webgl_util.callAndCheck(gl, () => gl.deleteBuffer(this.indexBuffer));\n    this.disposed = true;\n  }\n\n  public createFloat32MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat32MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createFloat16MatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16MatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createUnsignedBytesMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createUnsignedBytesMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public uploadPixelDataToTexture(\n      texture: WebGLTexture,\n      pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      ImageBitmap) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);\n  }\n\n  public uploadDenseMatrixToTexture(\n      texture: WebGLTexture, width: number, height: number, data: TypedArray) {\n    this.throwIfDisposed();\n    gpgpu_util.uploadDenseMatrixToTexture(\n        this.gl, texture, width, height, data, this.textureConfig);\n  }\n\n  public createFloat16PackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createFloat16PackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public createPackedMatrixTexture(rows: number, columns: number):\n      WebGLTexture {\n    this.throwIfDisposed();\n    return gpgpu_util.createPackedMatrixTexture(\n        this.gl, rows, columns, this.textureConfig);\n  }\n\n  public deleteMatrixTexture(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    if (this.outputTexture === texture) {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n      this.outputTexture = null;\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.deleteTexture(texture));\n  }\n\n  public downloadByteEncodedFloatMatrixFromOutputTexture(\n      texture: WebGLTexture, rows: number, columns: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadByteEncodedFloatMatrixFromOutputTexture(\n            this.gl, rows, columns, this.textureConfig));\n  }\n\n  public downloadPackedMatrixFromBuffer(\n      buffer: WebGLBuffer, batch: number, rows: number, columns: number,\n      physicalRows: number, physicalCols: number): Float32Array {\n    return gpgpu_util.downloadPackedMatrixFromBuffer(\n        this.gl, buffer, batch, rows, columns, physicalRows, physicalCols,\n        this.textureConfig);\n  }\n\n  public downloadFloat32MatrixFromBuffer(buffer: WebGLBuffer, size: number):\n      Float32Array {\n    return gpgpu_util.downloadFloat32MatrixFromBuffer(this.gl, buffer, size);\n  }\n\n  public createBufferFromTexture(\n      texture: WebGLTexture, rows: number, columns: number): WebGLBuffer {\n    this.bindTextureToFrameBuffer(texture);\n    const result = gpgpu_util.createBufferFromOutputTexture(\n        this.gl as WebGL2RenderingContext, rows, columns, this.textureConfig);\n    this.unbindTextureToFrameBuffer();\n    return result;\n  }\n\n  public createAndWaitForFence(): Promise<void> {\n    const fenceContext = this.createFence(this.gl);\n    return this.pollFence(fenceContext);\n  }\n\n  private createFence(gl: WebGLRenderingContext): FenceContext {\n    let query: WebGLQuery|WebGLSync;\n    let isFencePassed: () => boolean;\n\n    if (env().getBool('WEBGL_FENCE_API_ENABLED')) {\n      const gl2 = gl as WebGL2RenderingContext;\n\n      const sync = gl2.fenceSync(gl2.SYNC_GPU_COMMANDS_COMPLETE, 0);\n      gl.flush();\n\n      isFencePassed = () => {\n        const status = gl2.clientWaitSync(sync, 0, 0);\n        return status === gl2.ALREADY_SIGNALED ||\n            status === gl2.CONDITION_SATISFIED;\n      };\n\n      query = sync;\n    } else if (\n        env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {\n      query = this.beginQuery();\n      this.endQuery();\n      isFencePassed = () => this.isQueryAvailable(\n          query,\n          env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n    } else {\n      // If we have no way to fence, return true immediately. This will fire in\n      // WebGL 1.0 when there is no disjoint query timer. In this case, because\n      // the fence passes immediately, we'll immediately ask for a download of\n      // the texture, which will cause the UI thread to hang.\n      isFencePassed = () => true;\n    }\n\n    return {query, isFencePassed};\n  }\n\n  public downloadMatrixFromPackedTexture(\n      texture: WebGLTexture, physicalRows: number,\n      physicalCols: number): Float32Array {\n    return this.downloadMatrixDriver(\n        texture,\n        () => gpgpu_util.downloadMatrixFromPackedOutputTexture(\n            this.gl, physicalRows, physicalCols));\n  }\n\n  private vertexAttrsAreBound = false;\n\n  public createProgram(fragmentShaderSource: string): WebGLProgram {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    const fragmentShader: WebGLShader =\n        webgl_util.createFragmentShader(gl, fragmentShaderSource);\n    if (this.vertexShader == null) {\n      this.vertexShader = gpgpu_util.createVertexShader(gl);\n    }\n    const program: WebGLProgram = webgl_util.createProgram(gl);\n    webgl_util.callAndCheck(\n        gl, () => gl.attachShader(program, this.vertexShader));\n    webgl_util.callAndCheck(gl, () => gl.attachShader(program, fragmentShader));\n    webgl_util.linkProgram(gl, program);\n    if (this.debug) {\n      webgl_util.validateProgram(gl, program);\n    }\n    if (!this.vertexAttrsAreBound) {\n      this.setProgram(program);\n      this.vertexAttrsAreBound = gpgpu_util.bindVertexProgramAttributeStreams(\n          gl, this.program, this.vertexBuffer);\n    }\n    return program;\n  }\n\n  public deleteProgram(program: WebGLProgram) {\n    this.throwIfDisposed();\n    if (program === this.program) {\n      this.program = null;\n    }\n    if (program != null) {\n      webgl_util.callAndCheck(this.gl, () => this.gl.deleteProgram(program));\n    }\n  }\n\n  public setProgram(program: WebGLProgram|null) {\n    this.throwIfDisposed();\n    this.program = program;\n    if ((this.program != null) && this.debug) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.callAndCheck(this.gl, () => this.gl.useProgram(program));\n  }\n\n  public getUniformLocation(\n      program: WebGLProgram, uniformName: string,\n      shouldThrow = true): WebGLUniformLocation {\n    this.throwIfDisposed();\n    if (shouldThrow) {\n      return webgl_util.getProgramUniformLocationOrThrow(\n          this.gl, program, uniformName);\n    } else {\n      return webgl_util.getProgramUniformLocation(\n          this.gl, program, uniformName);\n    }\n  }\n\n  public getAttributeLocation(program: WebGLProgram, attribute: string):\n      number {\n    this.throwIfDisposed();\n    return webgl_util.callAndCheck(\n        this.gl, () => this.gl.getAttribLocation(program, attribute));\n  }\n\n  public getUniformLocationNoThrow(program: WebGLProgram, uniformName: string):\n      WebGLUniformLocation {\n    this.throwIfDisposed();\n    return this.gl.getUniformLocation(program, uniformName);\n  }\n\n  public setInputMatrixTexture(\n      inputMatrixTexture: WebGLTexture, uniformLocation: WebGLUniformLocation,\n      textureUnit: number) {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    webgl_util.bindTextureToProgramUniformSampler(\n        this.gl, inputMatrixTexture, uniformLocation, textureUnit);\n  }\n\n  public setOutputMatrixTexture(\n      outputMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);\n  }\n\n  public setOutputPackedMatrixTexture(\n      outputPackedMatrixTexture: WebGLTexture, rows: number, columns: number) {\n    this.throwIfDisposed();\n    const [width, height] =\n        tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns);\n    this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);\n  }\n\n  public setOutputMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    this.setOutputMatrixWriteRegionDriver(\n        startColumn, startRow, numColumns, numRows);\n  }\n\n  public setOutputPackedMatrixWriteRegion(\n      startRow: number, numRows: number, startColumn: number,\n      numColumns: number) {\n    throw new Error('setOutputPackedMatrixWriteRegion not implemented.');\n  }\n\n  public debugValidate() {\n    if (this.program != null) {\n      webgl_util.validateProgram(this.gl, this.program);\n    }\n    webgl_util.validateFramebuffer(this.gl);\n  }\n\n  public executeProgram() {\n    this.throwIfDisposed();\n    this.throwIfNoProgram();\n    const gl = this.gl;\n    if (this.debug) {\n      this.debugValidate();\n    }\n    webgl_util.callAndCheck(\n        gl, () => gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0));\n  }\n\n  public blockUntilAllProgramsCompleted() {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(this.gl, () => this.gl.finish());\n  }\n\n  private getQueryTimerExtension(): WebGL1DisjointQueryTimerExtension\n      |WebGL2DisjointQueryTimerExtension {\n    if (this.disjointQueryTimerExtension == null) {\n      this.disjointQueryTimerExtension =\n          webgl_util.getExtensionOrThrow(\n              this.gl,\n              env().getNumber(\n                  'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?\n                  'EXT_disjoint_timer_query_webgl2' :\n                  'EXT_disjoint_timer_query') as\n              WebGL1DisjointQueryTimerExtension |\n          WebGL2DisjointQueryTimerExtension;\n    }\n    return this.disjointQueryTimerExtension;\n  }\n\n  private getQueryTimerExtensionWebGL2(): WebGL2DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension();\n  }\n\n  private getQueryTimerExtensionWebGL1(): WebGL1DisjointQueryTimerExtension {\n    return this.getQueryTimerExtension() as WebGL1DisjointQueryTimerExtension;\n  }\n\n  beginQuery(): WebGLQuery {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const query = gl2.createQuery();\n      gl2.beginQuery(ext.TIME_ELAPSED_EXT, query);\n      return query;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    const query = ext.createQueryEXT() as WebGLQuery;\n    ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);\n    return query;\n  }\n\n  endQuery() {\n    if (env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n      gl2.endQuery(ext.TIME_ELAPSED_EXT);\n      return;\n    }\n    const ext = this.getQueryTimerExtensionWebGL1();\n    ext.endQueryEXT(ext.TIME_ELAPSED_EXT);\n  }\n\n  public async waitForQueryAndGetTime(query: WebGLQuery): Promise<number> {\n    await util.repeatedTry(\n        () => this.disposed ||  // while testing contexts are created / disposed\n                                // in rapid succession, so without this check we\n                                // may poll for the query timer indefinitely\n            this.isQueryAvailable(\n                query,\n                env().getNumber(\n                    'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION')));\n    return this.getQueryTime(\n        query, env().getNumber('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION'));\n  }\n\n  private getQueryTime(query: WebGLQuery, queryTimerVersion: number): number {\n    if (queryTimerVersion === 0) {\n      return null;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n\n      const timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const timeElapsedNanos =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);\n      // Return milliseconds.\n      return timeElapsedNanos / 1000000;\n    }\n  }\n\n  private isQueryAvailable(query: WebGLQuery, queryTimerVersion: number):\n      boolean {\n    if (queryTimerVersion === 0) {\n      return true;\n    }\n\n    if (queryTimerVersion === 2) {\n      const gl2 = this.gl as WebGL2RenderingContext;\n      const ext = this.getQueryTimerExtensionWebGL2();\n\n      const available =\n          gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    } else {\n      const ext = this.getQueryTimerExtensionWebGL1();\n\n      const available =\n          ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);\n      if (this.disjoint == null) {\n        this.disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);\n      }\n\n      return available && !this.disjoint;\n    }\n  }\n\n  pollFence(fenceContext: FenceContext) {\n    return new Promise<void>(resolve => {\n      this.addItemToPoll(() => fenceContext.isFencePassed(), () => resolve());\n    });\n  }\n\n  private itemsToPoll: PollItem[] = [];\n\n  pollItems(): void {\n    // Find the last query that has finished.\n    const index = linearSearchLastTrue(this.itemsToPoll.map(x => x.isDoneFn));\n    for (let i = 0; i <= index; ++i) {\n      const {resolveFn} = this.itemsToPoll[i];\n      resolveFn();\n    }\n    this.itemsToPoll = this.itemsToPoll.slice(index + 1);\n  }\n\n  private addItemToPoll(isDoneFn: () => boolean, resolveFn: () => void) {\n    this.itemsToPoll.push({isDoneFn, resolveFn});\n    if (this.itemsToPoll.length > 1) {\n      // We already have a running loop that polls.\n      return;\n    }\n    // Start a new loop that polls.\n    util.repeatedTry(() => {\n      this.pollItems();\n      // End the loop if no more items to poll.\n      return this.itemsToPoll.length === 0;\n    });\n  }\n\n  private bindTextureToFrameBuffer(texture: WebGLTexture) {\n    this.throwIfDisposed();\n    webgl_util.bindColorTextureToFramebuffer(\n        this.gl, texture, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(this.gl);\n    }\n  }\n\n  private unbindTextureToFrameBuffer() {\n    if (this.outputTexture != null) {\n      webgl_util.bindColorTextureToFramebuffer(\n          this.gl, this.outputTexture, this.framebuffer);\n      if (this.debug) {\n        webgl_util.validateFramebuffer(this.gl);\n      }\n    } else {\n      webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);\n    }\n  }\n\n  private downloadMatrixDriver(\n      texture: WebGLTexture,\n      downloadAndDecode: () => Float32Array): Float32Array {\n    this.bindTextureToFrameBuffer(texture);\n    const result = downloadAndDecode();\n    this.unbindTextureToFrameBuffer();\n\n    return result;\n  }\n\n  private setOutputMatrixTextureDriver(\n      outputMatrixTextureMaybePacked: WebGLTexture, width: number,\n      height: number) {\n    this.throwIfDisposed();\n    const gl = this.gl;\n    webgl_util.bindColorTextureToFramebuffer(\n        gl, outputMatrixTextureMaybePacked, this.framebuffer);\n    if (this.debug) {\n      webgl_util.validateFramebuffer(gl);\n    }\n    this.outputTexture = outputMatrixTextureMaybePacked;\n    webgl_util.callAndCheck(gl, () => gl.viewport(0, 0, width, height));\n    webgl_util.callAndCheck(gl, () => gl.scissor(0, 0, width, height));\n  }\n\n  private setOutputMatrixWriteRegionDriver(\n      x: number, y: number, width: number, height: number) {\n    this.throwIfDisposed();\n    webgl_util.callAndCheck(\n        this.gl, () => this.gl.scissor(x, y, width, height));\n  }\n\n  private throwIfDisposed() {\n    if (this.disposed) {\n      throw new Error('Attempted to use disposed GPGPUContext.');\n    }\n  }\n\n  private throwIfNoProgram() {\n    if (this.program == null) {\n      throw new Error('No GPU program is currently set.');\n    }\n  }\n}\n\ntype PollItem = {\n  isDoneFn: () => boolean,\n  resolveFn: () => void\n};\n\n/**\n * Finds the index of the last true element using linear search.\n * Note: We can't do binary search because Chrome expects us to explicitly\n * test all fences before download:\n * https://github.com/tensorflow/tfjs/issues/1145\n */\nexport function linearSearchLastTrue(arr: Array<() => boolean>): number {\n  let i = 0;\n  for (; i < arr.length; ++i) {\n    const isDone = arr[i]();\n    if (!isDone) {\n      break;\n    }\n  }\n  return i - 1;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}