{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, GatherV2, util } from '@tensorflow/tfjs-core';\nimport { reshape } from './Reshape';\nimport { CppDType } from './types';\nlet wasmGather;\n\nfunction setup(backend) {\n  wasmGather = backend.wasm.cwrap('Gather', null\n  /*void*/\n  , ['number', 'number', 'array', 'number', 'number', 'number', 'array', 'number' // outId\n  ]);\n}\n\nfunction gatherV2(args) {\n  const {\n    backend,\n    inputs,\n    attrs\n  } = args;\n  const {\n    x,\n    indices\n  } = inputs;\n  const {\n    axis,\n    batchDims\n  } = attrs;\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(x, indices, parsedAxis, batchDims);\n  const flattenX = reshape({\n    inputs: {\n      x\n    },\n    attrs: {\n      shape: [shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize, shapeInfo.sliceSize]\n    },\n    backend\n  });\n  const indicesSize = util.sizeFromShape(indices.shape);\n  const flattenIndex = reshape({\n    inputs: {\n      x: indices\n    },\n    attrs: {\n      shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]\n    },\n    backend\n  });\n  const flattenOutputShape = [shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize, shapeInfo.sliceSize];\n  const out = backend.makeOutput(flattenOutputShape, x.dtype);\n\n  if (util.sizeFromShape(x.shape) === 0) {\n    return out;\n  }\n\n  const stridesSize = flattenX.shape.length - 1;\n  const xData = backend.dataIdMap.get(flattenX.dataId);\n  const xId = xData.id;\n  const indicesData = backend.dataIdMap.get(flattenIndex.dataId);\n  const indicesId = indicesData.id;\n  const outId = backend.dataIdMap.get(out.dataId).id;\n  const xStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(flattenX.shape)).buffer);\n  const outStridesBytes = new Uint8Array(new Int32Array(util.computeStrides(flattenOutputShape)).buffer);\n  wasmGather(xId, CppDType[x.dtype], xStridesBytes, stridesSize, indicesId, shapeInfo.batchSize, outStridesBytes, outId);\n  backend.disposeData(flattenX.dataId);\n  backend.disposeData(flattenIndex.dataId); // reshape\n\n  out.shape = shapeInfo.outputShape;\n  return out;\n}\n\nexport const gatherV2Config = {\n  kernelName: GatherV2,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: gatherV2\n};","map":{"version":3,"sources":["../../src/kernels/GatherV2.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAR,EAAsB,QAAtB,EAA6G,IAA7G,QAAwH,uBAAxH;AAIA,SAAQ,OAAR,QAAsB,WAAtB;AACA,SAAQ,QAAR,QAAuB,SAAvB;AAEA,IAAI,UAAJ;;AAKA,SAAS,KAAT,CAAe,OAAf,EAAmC;AACjC,EAAA,UAAU,GAAG,OAAO,CAAC,IAAR,CAAa,KAAb,CAAmB,QAAnB,EAA6B;AAAK;AAAlC,IAA4C,CACvD,QADuD,EAEvD,QAFuD,EAGvD,OAHuD,EAIvD,QAJuD,EAKvD,QALuD,EAMvD,QANuD,EAOvD,OAPuD,EAQvD,QARuD,CAQ5C;AAR4C,GAA5C,CAAb;AAUD;;AAED,SAAS,QAAT,CACI,IADJ,EAC8E;AAE5E,QAAM;AAAC,IAAA,OAAD;AAAU,IAAA,MAAV;AAAkB,IAAA;AAAlB,MAA2B,IAAjC;AACA,QAAM;AAAC,IAAA,CAAD;AAAI,IAAA;AAAJ,MAAe,MAArB;AACA,QAAM;AAAC,IAAA,IAAD;AAAO,IAAA;AAAP,MAAoB,KAA1B;AAEA,QAAM,UAAU,GAAG,IAAI,CAAC,cAAL,CAAoB,IAApB,EAA0B,CAAC,CAAC,KAA5B,EAAmC,CAAnC,CAAnB;AACA,QAAM,SAAS,GAAG,YAAY,CAAC,YAAb,CAA0B,wBAA1B,CACd,CADc,EACD,OADC,EACkB,UADlB,EAC8B,SAD9B,CAAlB;AAGA,QAAM,QAAQ,GAAG,OAAO,CAAC;AACvB,IAAA,MAAM,EAAE;AAAC,MAAA;AAAD,KADe;AAEvB,IAAA,KAAK,EAAE;AACL,MAAA,KAAK,EAAE,CACL,SAAS,CAAC,SADL,EACgB,SAAS,CAAC,SAD1B,EACqC,SAAS,CAAC,OAD/C,EAEL,SAAS,CAAC,SAFL;AADF,KAFgB;AAQvB,IAAA;AARuB,GAAD,CAAxB;AAUA,QAAM,WAAW,GAAG,IAAI,CAAC,aAAL,CAAmB,OAAO,CAAC,KAA3B,CAApB;AACA,QAAM,YAAY,GAAG,OAAO,CAAC;AAC3B,IAAA,MAAM,EAAE;AAAC,MAAA,CAAC,EAAE;AAAJ,KADmB;AAE3B,IAAA,KAAK,EAAE;AAAC,MAAA,KAAK,EAAE,CAAC,SAAS,CAAC,SAAX,EAAsB,WAAW,GAAG,SAAS,CAAC,SAA9C;AAAR,KAFoB;AAG3B,IAAA;AAH2B,GAAD,CAA5B;AAKA,QAAM,kBAAkB,GAAG,CACzB,SAAS,CAAC,SADe,EACJ,SAAS,CAAC,SADN,EACiB,WAAW,GAAG,SAAS,CAAC,SADzC,EAEzB,SAAS,CAAC,SAFe,CAA3B;AAKA,QAAM,GAAG,GAAG,OAAO,CAAC,UAAR,CAAmB,kBAAnB,EAAuC,CAAC,CAAC,KAAzC,CAAZ;;AACA,MAAI,IAAI,CAAC,aAAL,CAAmB,CAAC,CAAC,KAArB,MAAgC,CAApC,EAAuC;AACrC,WAAO,GAAP;AACD;;AACD,QAAM,WAAW,GAAG,QAAQ,CAAC,KAAT,CAAe,MAAf,GAAwB,CAA5C;AAEA,QAAM,KAAK,GAAG,OAAO,CAAC,SAAR,CAAkB,GAAlB,CAAsB,QAAQ,CAAC,MAA/B,CAAd;AACA,QAAM,GAAG,GAAG,KAAK,CAAC,EAAlB;AAEA,QAAM,WAAW,GAAG,OAAO,CAAC,SAAR,CAAkB,GAAlB,CAAsB,YAAY,CAAC,MAAnC,CAApB;AACA,QAAM,SAAS,GAAG,WAAW,CAAC,EAA9B;AAEA,QAAM,KAAK,GAAG,OAAO,CAAC,SAAR,CAAkB,GAAlB,CAAsB,GAAG,CAAC,MAA1B,EAAkC,EAAhD;AAEA,QAAM,aAAa,GAAG,IAAI,UAAJ,CAClB,IAAI,UAAJ,CAAe,IAAI,CAAC,cAAL,CAAoB,QAAQ,CAAC,KAA7B,CAAf,EAAoD,MADlC,CAAtB;AAEA,QAAM,eAAe,GAAG,IAAI,UAAJ,CACpB,IAAI,UAAJ,CAAe,IAAI,CAAC,cAAL,CAAoB,kBAApB,CAAf,EAAwD,MADpC,CAAxB;AAGA,EAAA,UAAU,CACN,GADM,EACD,QAAQ,CAAC,CAAC,CAAC,KAAH,CADP,EACkB,aADlB,EACiC,WADjC,EAC8C,SAD9C,EAEN,SAAS,CAAC,SAFJ,EAEe,eAFf,EAEgC,KAFhC,CAAV;AAIA,EAAA,OAAO,CAAC,WAAR,CAAoB,QAAQ,CAAC,MAA7B;AACA,EAAA,OAAO,CAAC,WAAR,CAAoB,YAAY,CAAC,MAAjC,EAvD4E,CAyD5E;;AACA,EAAA,GAAG,CAAC,KAAJ,GAAY,SAAS,CAAC,WAAtB;AACA,SAAO,GAAP;AACD;;AAED,OAAO,MAAM,cAAc,GAAiB;AAC1C,EAAA,UAAU,EAAE,QAD8B;AAE1C,EAAA,WAAW,EAAE,MAF6B;AAG1C,EAAA,SAAS,EAAE,KAH+B;AAI1C,EAAA,UAAU,EAAE;AAJ8B,CAArC","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherV2, GatherV2Attrs, GatherV2Inputs, KernelConfig, KernelFunc, Tensor, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\n\nimport {reshape} from './Reshape';\nimport {CppDType} from './types';\n\nlet wasmGather: (\n    xId: number, dtype: CppDType, xStrides: Uint8Array, stridesSize: number,\n    indicesId: number, batchSize: number, outStrides: Uint8Array,\n    outId: number) => void;\n\nfunction setup(backend: BackendWasm): void {\n  wasmGather = backend.wasm.cwrap('Gather', null /*void*/, [\n    'number',  // xId\n    'number',  // dtype\n    'array',   // xStrides\n    'number',  // stridesSize\n    'number',  // indicesId\n    'number',  // batchSize\n    'array',   // outStrides\n    'number'   // outId\n  ]);\n}\n\nfunction gatherV2(\n    args: {backend: BackendWasm, inputs: GatherV2Inputs, attrs: GatherV2Attrs}):\n    TensorInfo {\n  const {backend, inputs, attrs} = args;\n  const {x, indices} = inputs;\n  const {axis, batchDims} = attrs;\n\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(\n      x as Tensor, indices as Tensor, parsedAxis, batchDims);\n\n  const flattenX = reshape({\n    inputs: {x},\n    attrs: {\n      shape: [\n        shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n        shapeInfo.sliceSize\n      ]\n    },\n    backend\n  });\n  const indicesSize = util.sizeFromShape(indices.shape);\n  const flattenIndex = reshape({\n    inputs: {x: indices},\n    attrs: {shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]},\n    backend\n  });\n  const flattenOutputShape = [\n    shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n    shapeInfo.sliceSize\n  ];\n\n  const out = backend.makeOutput(flattenOutputShape, x.dtype);\n  if (util.sizeFromShape(x.shape) === 0) {\n    return out;\n  }\n  const stridesSize = flattenX.shape.length - 1;\n\n  const xData = backend.dataIdMap.get(flattenX.dataId);\n  const xId = xData.id;\n\n  const indicesData = backend.dataIdMap.get(flattenIndex.dataId);\n  const indicesId = indicesData.id;\n\n  const outId = backend.dataIdMap.get(out.dataId).id;\n\n  const xStridesBytes = new Uint8Array(\n      new Int32Array(util.computeStrides(flattenX.shape)).buffer);\n  const outStridesBytes = new Uint8Array(\n      new Int32Array(util.computeStrides(flattenOutputShape)).buffer);\n\n  wasmGather(\n      xId, CppDType[x.dtype], xStridesBytes, stridesSize, indicesId,\n      shapeInfo.batchSize, outStridesBytes, outId);\n\n  backend.disposeData(flattenX.dataId);\n  backend.disposeData(flattenIndex.dataId);\n\n  // reshape\n  out.shape = shapeInfo.outputShape;\n  return out;\n}\n\nexport const gatherV2Config: KernelConfig = {\n  kernelName: GatherV2,\n  backendName: 'wasm',\n  setupFunc: setup,\n  kernelFunc: gatherV2 as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}