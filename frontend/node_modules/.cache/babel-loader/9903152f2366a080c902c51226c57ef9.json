{"ast":null,"code":"import _slicedToArray from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, TopK, util } from '@tensorflow/tfjs-core';\nimport { topKImplCPU } from '../kernel_utils/shared';\nimport { MergeProgram, SwapProgram } from '../top_k_gpu';\nimport { fill } from './Fill';\nimport { gatherV2 } from './GatherV2';\nimport { reshape } from './Reshape';\nimport { slice } from './Slice';\n\nfunction disposeIntermediateTensorInfoOrNull(backend, tensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n}\n\nfunction roundUpToPow2(num) {\n  var pow2 = 1;\n\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n\n  return pow2;\n} // Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\n\n\nexport function topK(args) {\n  var inputs = args.inputs,\n      backend = args.backend,\n      attrs = args.attrs;\n  var x = inputs.x;\n  var k = attrs.k,\n      sorted = attrs.sorted; // Empirically determined constant used to determine last dim threshold for\n  // handing off execution to the CPU.\n\n  var TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD = env().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD'); // Empirically determined constant used to determine k threshold for handing\n  // off execution to the CPU.\n\n  var TOPK_K_CPU_HANDOFF_THRESHOLD = env().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');\n  var xShape = x.shape;\n  var lastDim = xShape[xShape.length - 1];\n\n  if (backend.shouldExecuteOnCPU([x]) || lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD || k > TOPK_K_CPU_HANDOFF_THRESHOLD) {\n    var xVals = backend.readSync(x.dataId);\n\n    var _topKImplCPU = topKImplCPU(xVals, xShape, x.dtype, k, sorted),\n        _topKImplCPU2 = _slicedToArray(_topKImplCPU, 2),\n        allTopKVals = _topKImplCPU2[0],\n        allTopKIndices = _topKImplCPU2[1];\n\n    return [backend.makeTensorInfo(allTopKVals.shape, allTopKVals.dtype, allTopKVals.values), backend.makeTensorInfo(allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)];\n  }\n\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [backend.makeTensorInfo(xShape, x.dtype, []), backend.makeTensorInfo(xShape, 'int32', [])];\n  }\n\n  if (lastDim === 1\n  /* firstPass */\n  ) {\n      return [x, fill({\n        attrs: {\n          shape: xShape,\n          dtype: 'int32',\n          value: 0\n        },\n        backend: backend\n      })];\n    } // Eagerly unpack x input since it is passed in to all the shaders which\n  // require unpacked inputs.\n\n\n  var xtexData = backend.texData.get(x.dataId);\n  var xIsPacked = xtexData !== null && xtexData.isPacked;\n  var xUnPacked = xIsPacked ? backend.unpackTensor(x) : x; // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n\n  var xSize = util.sizeFromShape(xShape);\n  var batch = xSize / lastDim;\n  var x2D = reshape({\n    inputs: {\n      x: xUnPacked\n    },\n    attrs: {\n      shape: [batch, lastDim]\n    },\n    backend: backend\n  });\n\n  if (xIsPacked) {\n    disposeIntermediateTensorInfoOrNull(backend, xUnPacked);\n  }\n\n  var kPow2 = roundUpToPow2(k);\n  var lastDimPow2 = roundUpToPow2(lastDim); // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n\n  var indices = null; // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n\n  var getInputs = function getInputs() {\n    return indices === null ? [x2D, x2D] : [x2D, indices];\n  };\n\n  var runSwap = function runSwap(dir, inc, shape) {\n    var inputs = getInputs();\n    var program = new SwapProgram(shape);\n    var fistPass = indices === null ? 1 : 0;\n    var customValues = [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];\n    var prevIndices = indices;\n    indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  }; // Step 1: local sort\n\n\n  for (var len = 1; len < kPow2; len *= 2) {\n    var dir = len * 2;\n\n    for (var inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  } // Step 2: merge\n\n\n  for (var indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    var _inputs = getInputs();\n\n    var mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    var firstPass = indices === null ? 1 : 0;\n    var customValues = [[lastDim], [firstPass], [kPow2]];\n    var _prevIndices = indices;\n    indices = backend.runWebGLProgram(mergeProgram, _inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, _prevIndices); // Step 3: rebuild\n\n    var _len = kPow2 / 2;\n\n    var _dir = _len * 2;\n\n    for (var _inc = _len; _inc >= 1; _inc /= 2) {\n      runSwap(_dir, _inc, indices.shape);\n    }\n  } // Keep only the requested top K results instead of kPow2\n\n\n  var prevIndices = indices;\n  indices = slice({\n    inputs: {\n      x: indices\n    },\n    backend: backend,\n    attrs: {\n      begin: 0,\n      size: [batch, k]\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices); // Gather values on last dimension\n\n  var values = gatherV2({\n    inputs: {\n      x: x2D,\n      indices: indices\n    },\n    backend: backend,\n    attrs: {\n      axis: 1,\n      batchDims: 1\n    }\n  });\n  disposeIntermediateTensorInfoOrNull(backend, x2D); // Reshape back to the original input shape, except that the last\n  // dimension is k.\n\n  var newShape = xShape.slice(0, -1);\n  newShape.push(k);\n  prevIndices = indices;\n  indices = reshape({\n    inputs: {\n      x: indices\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend: backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  var prevValues = values;\n  values = reshape({\n    inputs: {\n      x: values\n    },\n    attrs: {\n      shape: newShape\n    },\n    backend: backend\n  });\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n  return [values, indices];\n}\nexport var topKConfig = {\n  kernelName: TopK,\n  backendName: 'webgl',\n  kernelFunc: topK\n};","map":{"version":3,"sources":["../../src/kernels/TopK.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc, NumericDataType, TensorInfo, TopK, TopKAttrs, TopKInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {topKImplCPU} from '../kernel_utils/shared';\nimport {MergeProgram, SwapProgram} from '../top_k_gpu';\nimport {fill} from './Fill';\nimport {gatherV2} from './GatherV2';\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nfunction disposeIntermediateTensorInfoOrNull(\n    backend: MathBackendWebGL, tensorInfo: TensorInfo) {\n  if (tensorInfo !== null) {\n    backend.disposeIntermediateTensorInfo(tensorInfo);\n  }\n}\n\nfunction roundUpToPow2(num: number) {\n  let pow2 = 1;\n  while (pow2 < num) {\n    pow2 *= 2;\n  }\n  return pow2;\n}\n\n// Based on Algorithm 2 of Bitonic Top K, ref:\n// https://anilshanbhag.in/static/papers/gputopk_sigmod18.pdf\nexport function topK(\n    args: {inputs: TopKInputs, backend: MathBackendWebGL, attrs: TopKAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {k, sorted} = attrs;\n\n  // Empirically determined constant used to determine last dim threshold for\n  // handing off execution to the CPU.\n  const TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD =\n      env().getNumber('TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD');\n\n  // Empirically determined constant used to determine k threshold for handing\n  // off execution to the CPU.\n  const TOPK_K_CPU_HANDOFF_THRESHOLD =\n      env().getNumber('TOPK_K_CPU_HANDOFF_THRESHOLD');\n\n  const xShape = x.shape;\n  const lastDim = xShape[xShape.length - 1];\n\n  if (backend.shouldExecuteOnCPU([x]) ||\n      lastDim < TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD ||\n      k > TOPK_K_CPU_HANDOFF_THRESHOLD) {\n    const xVals = backend.readSync(x.dataId) as TypedArray;\n    const [allTopKVals, allTopKIndices] =\n        topKImplCPU(xVals, xShape, x.dtype as NumericDataType, k, sorted);\n\n    return [\n      backend.makeTensorInfo(\n          allTopKVals.shape, allTopKVals.dtype, allTopKVals.values),\n      backend.makeTensorInfo(\n          allTopKIndices.shape, allTopKIndices.dtype, allTopKIndices.values)\n    ];\n  }\n\n  if (k === 0) {\n    xShape[xShape.length - 1] = 0;\n    return [\n      backend.makeTensorInfo(xShape, x.dtype, []),\n      backend.makeTensorInfo(xShape, 'int32', [])\n    ];\n  }\n\n  if (lastDim === 1 /* firstPass */) {\n    return [\n      x, fill({attrs: {shape: xShape, dtype: 'int32', value: 0}, backend})\n    ];\n  }\n\n  // Eagerly unpack x input since it is passed in to all the shaders which\n  // require unpacked inputs.\n  const xtexData = backend.texData.get(x.dataId);\n  const xIsPacked = xtexData !== null && xtexData.isPacked;\n  const xUnPacked = xIsPacked ? backend.unpackTensor(x) : x;\n\n  // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n  const xSize = util.sizeFromShape(xShape);\n  const batch = xSize / lastDim;\n  const x2D = reshape(\n      {inputs: {x: xUnPacked}, attrs: {shape: [batch, lastDim]}, backend});\n\n  if (xIsPacked) {\n    disposeIntermediateTensorInfoOrNull(backend, xUnPacked);\n  }\n\n  const kPow2 = roundUpToPow2(k);\n  const lastDimPow2 = roundUpToPow2(lastDim);\n\n  // Only the indices containing the top K are kept at every step to reduce\n  // number of outputs in the GPU algorithms, so once the final set of indices\n  // is computed then gather is used to grab the corresponding values\n  // from the original input.\n  let indices: TensorInfo = null;\n\n  // GPU algorithm always takes in an indices input but this input is not used\n  // on the first run of a GPU algorithm, therefore if indices is null we simply\n  // pass in x2D instead of it but the value will not actually be used\n  const getInputs = () => indices === null ? [x2D, x2D] : [x2D, indices];\n\n  const runSwap = (dir: number, inc: number, shape: number[]) => {\n    const inputs = getInputs();\n    const program = new SwapProgram(shape);\n    const fistPass = indices === null ? 1 : 0;\n    const customValues =\n        [[lastDim], [fistPass], [Number.NEGATIVE_INFINITY], [dir], [inc]];\n    const prevIndices = indices;\n    indices = backend.runWebGLProgram(program, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n  };\n\n  // Step 1: local sort\n  for (let len = 1; len < kPow2; len *= 2) {\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, [batch, lastDimPow2]);\n    }\n  }\n\n  // Step 2: merge\n  for (let indicesSize = lastDimPow2; indicesSize > kPow2; indicesSize /= 2) {\n    const inputs = getInputs();\n    const mergeProgram = new MergeProgram([batch, indicesSize / 2]);\n    const firstPass = indices === null ? 1 : 0;\n    const customValues = [[lastDim], [firstPass], [kPow2]];\n    const prevIndices = indices;\n    indices =\n        backend.runWebGLProgram(mergeProgram, inputs, 'int32', customValues);\n    disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n    // Step 3: rebuild\n    const len = kPow2 / 2;\n    const dir = len * 2;\n    for (let inc = len; inc >= 1; inc /= 2) {\n      runSwap(dir, inc, indices.shape);\n    }\n  }\n\n  // Keep only the requested top K results instead of kPow2\n  let prevIndices = indices;\n  indices = slice(\n      {inputs: {x: indices}, backend, attrs: {begin: 0, size: [batch, k]}});\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n  // Gather values on last dimension\n  let values = gatherV2(\n      {inputs: {x: x2D, indices}, backend, attrs: {axis: 1, batchDims: 1}});\n  disposeIntermediateTensorInfoOrNull(backend, x2D);\n\n  // Reshape back to the original input shape, except that the last\n  // dimension is k.\n  const newShape = xShape.slice(0, -1);\n  newShape.push(k);\n\n  prevIndices = indices;\n  indices = reshape({inputs: {x: indices}, attrs: {shape: newShape}, backend});\n  disposeIntermediateTensorInfoOrNull(backend, prevIndices);\n\n  const prevValues = values;\n  values = reshape({inputs: {x: values}, attrs: {shape: newShape}, backend});\n  disposeIntermediateTensorInfoOrNull(backend, prevValues);\n\n  return [values, indices];\n}\n\nexport const topKConfig: KernelConfig = {\n  kernelName: TopK,\n  backendName: 'webgl',\n  kernelFunc: topK as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}