{"ast":null,"code":"import _slicedToArray from \"/Users/alberttian/f21/playground/frontend/fencing-ai-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { Slice, slice_util, util } from '@tensorflow/tfjs-core';\nimport { sliceImplCPU } from '../kernel_utils/shared';\nexport function slice(args) {\n  var x = args.inputs.x,\n      _args$attrs = args.attrs,\n      begin = _args$attrs.begin,\n      size = _args$attrs.size,\n      backend = args.backend;\n\n  var _slice_util$parseSlic = slice_util.parseSliceParams(x, begin, size),\n      _slice_util$parseSlic2 = _slicedToArray(_slice_util$parseSlic, 2),\n      begin_ = _slice_util$parseSlic2[0],\n      size_ = _slice_util$parseSlic2[1];\n\n  var isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n  var xVals = backend.readSync(x.dataId);\n  var out = backend.makeOutput(size_, x.dtype);\n  var xStrides = util.computeStrides(x.shape);\n  var outData = backend.dataIdMap.get(out.dataId);\n\n  if (isContinous) {\n    var flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n\n    if (x.dtype === 'string') {\n      outData.stringBytes = xVals.slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n    } else {\n      var _outVals = backend.typedArrayFromHeap(out);\n\n      _outVals.set(xVals.subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n    }\n\n    return out;\n  }\n\n  if (x.dtype === 'string') {\n    var res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outData.stringBytes = res;\n    return out;\n  }\n\n  var outVals = backend.typedArrayFromHeap(out);\n  var rank = x.shape.length;\n\n  if (rank === 2) {\n    slice2d(xVals, xStrides[0], outVals, begin_, size_);\n  } else if (rank === 3) {\n    slice3d(xVals, xStrides[0], xStrides[1], outVals, begin_, size_);\n  } else if (rank === 4) {\n    slice4d(xVals, xStrides[0], xStrides[1], xStrides[2], outVals, begin_, size_);\n  } else {\n    var _res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n\n    outVals.set(_res);\n  }\n\n  return out;\n}\n\nfunction slice2d(xVals, xStride, outVals, begin, size) {\n  var outOffset = 0;\n  var beginI = begin[0];\n  var beginJ = begin[1];\n  var endI = beginI + size[0];\n\n  for (var i = beginI; i < endI; i++) {\n    var xOffset = i * xStride + beginJ;\n    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n    outOffset += size[1];\n  }\n}\n\nfunction slice3d(xVals, xStride1, xStride2, outVals, begin, size) {\n  var outOffset = 0;\n  var beginI = begin[0];\n  var beginJ = begin[1];\n  var beginK = begin[2];\n  var endI = beginI + size[0];\n  var endJ = beginJ + size[1];\n\n  for (var i = beginI; i < endI; i++) {\n    for (var j = beginJ; j < endJ; j++) {\n      var xOffset = i * xStride1 + j * xStride2 + beginK;\n      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n      outOffset += size[2];\n    }\n  }\n}\n\nfunction slice4d(xVals, xStride1, xStride2, xStride3, outVals, begin, size) {\n  var outOffset = 0;\n  var beginI = begin[0];\n  var beginJ = begin[1];\n  var beginK = begin[2];\n  var endI = beginI + size[0];\n  var endJ = beginJ + size[1];\n  var endK = beginK + size[2];\n  var beginL = begin[3];\n\n  for (var i = beginI; i < endI; i++) {\n    for (var j = beginJ; j < endJ; j++) {\n      for (var k = beginK; k < endK; k++) {\n        var xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n        outOffset += size[3];\n      }\n    }\n  }\n}\n\nexport var sliceConfig = {\n  kernelName: Slice,\n  backendName: 'wasm',\n  kernelFunc: slice\n};","map":{"version":3,"sources":["../../src/kernels/Slice.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {BackendWasm} from '../backend_wasm';\nimport {sliceImplCPU} from '../kernel_utils/shared';\n\nexport function slice(\n    args: {inputs: SliceInputs, attrs: SliceAttrs, backend: BackendWasm}) {\n  const {inputs: {x}, attrs: {begin, size}, backend} = args;\n\n  const [begin_, size_] = slice_util.parseSliceParams(x, begin, size);\n\n  const isContinous = slice_util.isSliceContinous(x.shape, begin_, size_);\n  const xVals = backend.readSync(x.dataId);\n  const out = backend.makeOutput(size_, x.dtype);\n  const xStrides = util.computeStrides(x.shape);\n  const outData = backend.dataIdMap.get(out.dataId);\n\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin_, xStrides);\n\n    if (x.dtype === 'string') {\n      outData.stringBytes =\n          (xVals as Uint8Array[])\n              .slice(flatOffset, flatOffset + util.sizeFromShape(size_));\n    } else {\n      const outVals = backend.typedArrayFromHeap(out);\n      outVals.set(\n          (xVals as TypedArray)\n              .subarray(flatOffset, flatOffset + util.sizeFromShape(size_)));\n    }\n\n    return out;\n  }\n\n  if (x.dtype === 'string') {\n    const res = sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype);\n    outData.stringBytes = res as Uint8Array[];\n    return out;\n  }\n\n  const outVals = backend.typedArrayFromHeap(out);\n  const rank = x.shape.length;\n  if (rank === 2) {\n    slice2d(\n        xVals as TypedArray, xStrides[0], outVals, begin_ as [number, number],\n        size_ as [number, number]);\n  } else if (rank === 3) {\n    slice3d(\n        xVals as TypedArray, xStrides[0], xStrides[1], outVals,\n        begin_ as [number, number, number], size_ as [number, number, number]);\n  } else if (rank === 4) {\n    slice4d(\n        xVals as TypedArray, xStrides[0], xStrides[1], xStrides[2], outVals,\n        begin_ as [number, number, number, number],\n        size_ as [number, number, number, number]);\n  } else {\n    const res =\n        sliceImplCPU(xVals, begin_, size_, x.shape, x.dtype) as TypedArray;\n    outVals.set(res);\n  }\n\n  return out;\n}\n\nfunction slice2d(\n    xVals: backend_util.TypedArray, xStride: number,\n    outVals: backend_util.TypedArray, begin: [number, number],\n    size: [number, number]): void {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const endI = beginI + size[0];\n  for (let i = beginI; i < endI; i++) {\n    const xOffset = i * xStride + beginJ;\n    outVals.set(xVals.subarray(xOffset, xOffset + size[1]), outOffset);\n    outOffset += size[1];\n  }\n}\n\nfunction slice3d(\n    xVals: backend_util.TypedArray, xStride1: number, xStride2: number,\n    outVals: backend_util.TypedArray, begin: [number, number, number],\n    size: [number, number, number]): void {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      const xOffset = i * xStride1 + j * xStride2 + beginK;\n      outVals.set(xVals.subarray(xOffset, xOffset + size[2]), outOffset);\n      outOffset += size[2];\n    }\n  }\n}\n\nfunction slice4d(\n    xVals: backend_util.TypedArray, xStride1: number, xStride2: number,\n    xStride3: number, outVals: backend_util.TypedArray,\n    begin: [number, number, number, number],\n    size: [number, number, number, number]): void {\n  let outOffset = 0;\n  const beginI = begin[0];\n  const beginJ = begin[1];\n  const beginK = begin[2];\n  const endI = beginI + size[0];\n  const endJ = beginJ + size[1];\n  const endK = beginK + size[2];\n  const beginL = begin[3];\n\n  for (let i = beginI; i < endI; i++) {\n    for (let j = beginJ; j < endJ; j++) {\n      for (let k = beginK; k < endK; k++) {\n        const xOffset = i * xStride1 + j * xStride2 + k * xStride3 + beginL;\n        outVals.set(xVals.subarray(xOffset, xOffset + size[3]), outOffset);\n        outOffset += size[3];\n      }\n    }\n  }\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'wasm',\n  kernelFunc: slice as {} as KernelFunc,\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}